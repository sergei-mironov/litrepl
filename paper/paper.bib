@inproceedings{Knuth1984lp,
  title={Literate Programming},
  author={Donald Ervin Knuth},
  booktitle={Computer/law journal},
  year={1984},
  url={https://api.semanticscholar.org/CorpusID:1200693}
}
@article{Ramsey1994lps,
  author = {Ramsey, Norman},
  title = {Literate Programming Simplified},
  year = {1994},
  issue_date = {September 1994},
  publisher = {IEEE Computer Society Press},
  address = {Washington, DC, USA},
  volume = {11},
  number = {5},
  issn = {0740-7459},
  url = {https://doi.org/10.1109/52.311070},
  doi = {10.1109/52.311070},
  abstract = {Literate programming tools let you arrange the parts of a program in any order and
              extract documentation and code from the same source file. The author argues that
              language-dependence and feature complexity have hampered acceptance of these tools,
              then offers a simpler alternative.},
  journal = {IEEE Softw.},
  month = sep,
  pages = {97–105},
  numpages = {9},
  keywords = {tool acceptance, system documentation, source file, software tools, programming
              environments, programming, literate programming tools, literate programming,
              language-dependence, feature complexity, documentation, code extraction}
}
@article{Perez2007IPython,
  title={IPython: A System for Interactive Scientific Computing},
  author={Fernando P{\'e}rez and Brian E. Granger},
  journal={Computing in Science \& Engineering},
  year={2007},
  volume={9},
  url={https://api.semanticscholar.org/CorpusID:16637923}
}
@article{Granger2021litcomp,
  author={Granger, Brian E. and Pérez, Fernando},
  journal={Computing in Science \& Engineering},
  title={Jupyter: Thinking and Storytelling With Code and Data},
  year={2021},
  volume={23},
  number={2},
  pages={7-14},
  keywords={Open source software;Scientific computing;Machine learning;Data science;Open source
            software;Meteorology},
  doi={10.1109/MCSE.2021.3059263},
  url={https://ieeexplore.ieee.org/document/9387490}
}
@inproceedings{Kluyver2016jupnb,
  title={Jupyter Notebooks - a publishing format for reproducible computational workflows},
  author={Thomas Kluyver and Benjamin Ragan-Kelley and Fernando P{\'e}rez and Brian E. Granger and Matthias Bussonnier and Jonathan Frederic and Kyle Kelley and Jessica B. Hamrick and Jason Grout and Sylvain Corlay and Paul Ivanov and Dami{\'a}n Avila and Safia Abdalla and Carol Willing and Jupyter Development Team},
  booktitle={International Conference on Electronic Publishing},
  year={2016},
  url={https://api.semanticscholar.org/CorpusID:36928206}
}
@inproceedings{McCarthy1959recfun,
  title={Recursive Functions of Symbolic Expressions and their Computation by Machine},
  author={John McCarthy},
  year={1959},
  url={https://api.semanticscholar.org/CorpusID:267886520}
}
@book{Iverson1962apl,
  author = {Iverson, Kenneth E.},
  title = {A programming language},
  year = {1962},
  isbn = {0471430145},
  publisher = {John Wiley \& Sons, Inc.},
  address = {USA},
  abstract = {From the PrefaceApplied mathematics is largely concerned with the design and analysis
              of explicit procedures for calculating the exact or approximate values of various
              functions. Such explicit procedures are called algorithms or programs. Because an
              effective notation for the description of programs exhibits considerable syntactic
              structure, it is called a programming language.Much of applied mathematics,
              particularly the more recent computer-related areas which cut across the older
              disciplines, suffers from the lack of an adequate programming language. It is the
              central thesis of this book that the descriptive and analytic power of an adequate
              programming language amply repays the considerable effort required for its mastery.
              This thesis is developed by first presenting the entire language and then applying it
              in later chapters to several major topics.The areas of application are chosen
              primarily for their intrinsic interest and lack of previous treatment, but they are
              also designed to illustrate the universality and other facets of the language. For
              example, the microprogramming of Chapter 2 illustrates the divisibility of the
              language, i.e., the ability to treat a restricted area using only a small portion of
              the complete language. Chapter 6 (Sorting) shows its capacity to compass a relatively
              complex and detailed topic in a short space. Chapter 7 (The Logical Calculus)
              emphasizes the formal manipulability of the language and its utility in theoretical
              work.The material was developed largely in a graduate course given for several years
              at Harvard and in a later course presented repeatedly at the IBM Systems Research
              Institute in New York. It should prove suitable for a two-semester course at the
              senior or graduate level. Although for certain audiences an initial presentation of
              the entire language may be appropriate, I have found it helpful to motivate the
              development by presenting the minimum notation required for a given topic, proceeding
              to its treatment (e.g., microprogramming), and then returning to further notation. The
              130-odd problems not only provide the necessary finger exercises but also develop
              results of general interest.Chapter 1 or some part of it is prerequisite to each of
              the remaining "applications" chapters, but the applications chapters are virtually
              independent of one another. A complete appreciation of search techniques (Chapter 4)
              does, however, require a knowledge of methods of representation (Chapter 3). The cross
              references which do occur in the applications chapters are either nonessential or are
              specific to a given figure, table, or program. The entire language presented in
              Chapter 1 is summarized for reference at the end of the book.},
  url={https://archive.org/embed/aprogramminglanguage1962}
}
@misc{Spence1975apl,
  author = {Spence R.},
  title = {APL Demonstration 1975},
  year = {2020},
  publisher = {Imperial College London via Youtube},
  journal = {Youtube video},
  url = {https://www.youtube.com/watch?v=_DTpQ4Kk2wA}
}
@article{Vallet2022,
  author = {Nicolas Vallet and David Michonneau and Simon Tournier},
  title = {Toward practical transparent verifiable and long-term reproducible
           research using Guix},
  journal = {Scientific Data},
  year = {2022},
  volume = {9},
  number = {1},
  pages = {597},
  month = {October},
  abstract = {Reproducibility crisis urge scientists to promote transparency
             which allows peers to draw same conclusions after performing
             identical steps from hypothesis to results. Growing resources
             are developed to open the access to methods, data and source
             codes. Still, the computational environment, an interface
             between data and source code running analyses, is not addressed.
             Environments are usually described with software and library
             names associated with version labels or provided as an opaque
             container image. This is not enough to describe the complexity of
             the dependencies on which they rely to operate on. We describe
             this issue and illustrate how open tools like Guix can be used
             by any scientist to share their environment and allow peers to
             reproduce it. Some steps of research might not be fully
             reproducible, but at least, transparency for computation is
             technically addressable. These tools should be considered by
             scientists willing to promote transparency and open science.},
  issn = {2052-4463},
  doi = {10.1038/s41597-022-01720-9},
  url = {https://doi.org/10.1038/s41597-022-01720-9}
}
@article{Dolstra2010,
  title={NixOS: A purely functional Linux distribution},
  volume={20},
  doi={10.1017/S0956796810000195},
  number={5–6},
  journal={Journal of Functional Programming},
  author={Eelco Dolstra and Andres Löh and Nicolas Pierron},
  year={2010},
  pages={577–615},
  url={https://www.cambridge.org/core/journals/journal-of-functional-programming/article/nixos-a-purely-functional-linux-distribution/C1ACBA2A51D2E5466820F5B5086EA2CE}
}
@techreport{POSIX2024,
  author = {{IEEE and The Open Group}},
  title = {POSIX Standard: Base Specifications, Issue 8},
  institution = {The Open Group},
  year = {2024},
  isbn = {1-957866-40-6},
  type = {Standard},
  number = {Issue 8},
  pages = {4107},
  month = {June},
  note = {Adopted Standard},
  keywords = {POSIX, UNIX, standard, operating system},
  url = {https://publications.opengroup.org/c243}
}
