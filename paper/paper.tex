\documentclass[a4paper,12pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{svg}
\usepackage{comment}
\usepackage{float}
\usepackage[font=small,skip=0pt]{caption}

\usepackage{biblatex}
\addbibresource{paper.bib}

\geometry{margin=1in}

\fancypagestyle{plain}{
  \fancyhf{}
  \lhead{Sergei Mironov}
  \rhead{Litrepl}
  \rfoot{\thepage}
}

\newcommand{\ls}{\begin{itemize}\item}
\newcommand{\li}{\item}
\renewcommand{\le}{\end{itemize}}

\newcommand{\es}{\begin{enumerate}\item}
\newcommand{\ei}{\item}
\newcommand{\ee}{\end{enumerate}}

\pagestyle{plain}

\title{Litrepl: Literate Paper Processor Promoting Transparency More Than Reproducibility}
\author{Sergei Mironov \\
        \texttt{sergei.v.mironov@proton.me}}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Litrepl is a Python text processor for recognizing and evaluation code sections
in Markdown or LaTeX documents. Litrepl is designed as a middleware aimed at
separating text editors from the programming language interpreter management
logic thus contributing to the diversity of both. In this role, Litrepl can
become a component of modular "UNIX Way" interactive development or typesetting
environments.
\end{abstract}

\section{Statement of Need}

\begin{figure*}[!hbt]
  \centering
  \includesvg[inkscapelatex=false,width=0.8\textwidth]{pic}
  \caption{Caption describing the image shown in the figure.}
  \label{fig:resource-allocation}
\end{figure*}

The concept of Literate Programming, initially proposed by Donald Knuth,
revolves around explaining to human beings what we want a computer to do. This
approach is embodied in tools like WEB, CWEB, and NOWEB, which focus on
non-interactive, ahead-of-time compilation. The process includes two primary
modes of operation: weaving, which creates human-readable documentation, and
tangling, which generates machine-executable code. Over time, the concept has
evolved, showing a trend towards simplification \cite{Knuth1984lp,
Ramsey1994lps}.

Concurrently, another concept of human-computer interaction called the
Read-Evaluate-Print Loop (REPL) gained traction, notably within the LISP
community and through the APL language designed for mathematical computations.
The combination of a command-line interface and a language interpreter enables
incremental and interactive programming, allowing users to directly modify the
interpreter state. By maintaining human involvement in the loop, this approach
facilitates human thought processes \cite{Spence1975apl, McCarthy1959recfun,
Iverson1962apl}.

A significant milestone in this area was the development of the IPython project,
which later evolved into the Jupyter Project. The creators introduced a new
document format called the Notebook, characterized by a series of logical
sections of various types, including text and code, which could directly
interact with programming language interpreters. This interactive communication,
akin to REPL style programming, allows the creation of well-structured documents
suitable for presentations and sharing. The concept underpinning these
developments is termed Literate Computing, which includes goals of spanning a
wide audience range, boosting reproducibility, and fostering collaboration. To
achieve these objectives, several technical decisions were made, notably the
introduction of bidirectional communication—between the computational core,
known as the Jupyter Kernel, and the Notebook acting as a client, along with
another layer of client-server communication between the Notebook web server and
the user’s web browser \cite{Perez2007IPython, Granger2021litcomp,
Kluyver2016jupnb}.

4. While we recognize the importance of various goals within the Literate
Computing framework, we argue that reproducibility is paramount. Successfully
addressing reproducibility would alone suffice to enhance communication over
time among research project participants and significantly expand the audience.
However, as it became clear (\cite{Dolstra2010, Vallet2022}), this challenge
extends far beyond the scope of a human-computer interaction system, and even
beyond the typical boundaries of software distribution management for a
particular programming language. A comprehensive solution to the software
deployment problem should operate at the entire operating system level.


5. Consequently, we propose focusing on transparency in human-computer
interaction rather than on reproducibility. We present "Litrepl," a tool
designed to integrate the REPL interactive programming style into existing
editors in a straightforward yet potent manner.

6. First, we utilize simple bidirectional text streams for inter-process
communication with language interpreters to evaluate code. Second, we advocate
for the reuse of existing text document formats. In both the Markdown and LaTeX
formats that we have implemented, simplified parsers are utilized to distinguish
code and result sections from the rest of the document. As of now, we support
Python and Shell interpreter families, as well as a custom AI communication
interpreter. Finally, we strive to leverage POSIX \cite{POSIX2024} operating
system facilities as much as possible.

\section{How it works}

Litrepl is implemented in Python as a command-line text processor utility. Its
primary function is to take a text document as input, process it according to
specified command line arguments and environment settings, and then output the
resulting document through its standard output.

The operation of Litrepl is best illustrated through the example below. Consider
the document named \verb|input.tex|:

\begin{comment}
\begin{sh}
echo '\begin{verbatim}'
echo '$ cat input.tex'
cat input.tex
echo '\end{verbatim}'
\end{sh}
\end{comment}
%lresult
\begin{verbatim}
$ cat input.tex
\begin{python}
import sys
print(f"I use {sys.platform} btw!")
\end{python}
\begin{result}
\end{result}
\end{verbatim}
%lnoresult

This document contains a Python code section and an empty result section marked
with the corresponding Latex environment tags. To "execute" the document we
pipe it though the Litrepl processor as follows:

\begin{comment}
\begin{sh}
echo '\begin{verbatim}'
echo '$ cat input.tex | litrepl'
echo "sys.platform='linux'" | litrepl repl python >/dev/null
cat input.tex | litrepl
echo '\end{verbatim}'
\end{sh}
\end{comment}
%lresult
\begin{verbatim}
$ cat input.tex | litrepl
\begin{python}
import sys
print(f"I use {sys.platform} btw!")
\end{python}
\begin{result}
I use linux btw!
\end{result}
\end{verbatim}
%lnoresult

Now we can see the expected statement about the author's operating system.  The
side-effect of this execution is the started session of the python interpreter
which is now running in the background. We can modify its state by adding more
section to the document and executing them selectively or e.g. by accessing
\verb|litrepl repl python| terminal. So for example, setting \verb|sys.platform|
to another value and re-evaluating the document would yield a different
statement.


\subsection{Interfacing Interpreters}

Litrepl communicates with interpreters using two uni-directional text streams:
one for writing input and another for reading outputs. To establish effective
communication, the interpreter should conform to the following general
assumptions:

\begin{itemize}
  \item Synchronous single-user mode, which is implemented in most interpreters.
  \item A capability to disable command line prompts. Litrepl relies on the echo
        response, as described below, rather than on prompt detection.
  \item The presence of an echo command or equivalent. The interpreter must be
        able to echo an argument string provided by the user in response to the
        echo command.
\end{itemize}

In Litrepl, these details are hardcoded for several prominent interpreter
families, which we refer to as \textit{interpreter classes}. At the time of
writing, Litrepl supports three such classes: \textbf{python}, \textbf{sh}, and
\textbf{ai}. Using command line arguments, users can configure how to map code
section labels to the correct class and specify which interpreter command to
execute to start a session for each class.

\subsection{Session Management}

\begin{comment}
\begin{sh}
echo -n '\begin' ; echo '{verbatim}'
echo '\begin{result}'
litrepl --python-auxdir=/tmp/litrepl/python restart python
{
cat <<EOF
import time
print('... some output ...')
time.sleep(9999)
EOF
}|litrepl --python-auxdir=/tmp/litrepl/python --timeout=1,inf eval-code python
echo '\end{result}'
echo -n '\end'; echo '{verbatim}'
\end{sh}
\end{comment}

\begin{figure*}[hbt!]
  \centering
  \begin{minipage}{\textwidth}
  %lresult
  \begin{verbatim}
  \begin{result}
  ... some output ...
  [LR:/tmp/litrepl/python/partial_7b81e1e.txt]
  \end{result}
  \end{verbatim}
  %lnoresult
  \end{minipage}
  \caption{Example output in a verbatim format displayed above two columns.}
  \label{fig:partial-result}
\end{figure*}

\begin{comment}
%lai
Lets rewrite the "Session management" section. Please consider the following
points, check the grammar and combine them into a linked narrative. Please
generate it using Latex markup. Wrap your own comments in Latex line comments.
Please don't generate figures. Just text.

----

1. As mentioned earlier, the necessary side-effect of code section evaluation,
which makes read-eval loop possible - is the the interpreter session left
running in the background. The resources required to manage this mode of
operation are shown on the Figure \ref{fig:resource-allocation}. All of them are
visible as files residing in some auxiliary directory.

2. If not set via arguments or environment, the path to this directory
is calculated out of interpreter class name, current working directory and the
operating system temporary folder name.

3. The code to be evaluated determines (via hashing) the name of the response file,
containing interpreter response for this code.

4. Also, aux. dir contains a couple of pipes providing an access to the
interpreter standard input and ouput streams.

5. Finally, the PID of the interpreter process is also stored in a file.

6. When evaluating, Litrepl forks a response reader which keeps it soft-locked
until the interpreter signals the completion by answering to the echo probe. If
the response takes longer than configured, Litrepl outputs a pratial response
result which can be read and checked for completion during next runs.

7. Litrepl provides \textbf{start}, \textbf{stop}, \textbf{restart} commands
accepting the name of interpreter class to act on to start, stop or restart
interpreter sessions.

----

%lnoai
\end{comment}

%lresult
Litrepl's ability to maintain interpreter sessions in the background is crucial
for enabling a Read-Eval-Print Loop (REPL) environment. These resources, shown
in Figure \ref{fig:resource-allocation}, are stored as files within an auxiliary
directory.

If not specified by command-line arguments or environment variables, the
directory path is automatically derived from the interpreter class name, the
current working directory, and the OS's temporary file location.

The auxiliary directory includes two POSIX pipes for interpreter I/O and a file
recording the running interpreter's process ID, aiding session management.

When a code section is evaluated, Litrepl assigns a response file name derived
from hashing the code. This response file stores the output from the
interpreter.

During evaluation, Litrepl spawns a response reader process with a soft lock,
active until the interpreter completes and responds to an echo probe. If the
response exceeds the configured duration, Litrepl outputs a partial result tag,
which is recognized and reevaluated in subsequent runs. Figure
\ref{fig:partial-result} shows an example partial result section.

Litrepl provides \textbf{start}, \textbf{stop}, and \textbf{restart} commands to
control background sessions. The \textbf{interrupt} command sends an
interruption signal to the interpreter. Finally, the \textbf{repl} command
establishes direct communication with the interpreter, allowing manual
inspection of its state.
%lnoresult

\subsection{Parsing and Evaluation}

%lignore
\begin{figure*}[hbt!]
  \centering
  \begin{minipage}{\textwidth}
  \begin{verbatim}
  document       ::= (code | result | ignore | text)*
  code           ::= (code-normal | code-comment)
  result         ::= (result-normal | result-comment)
  code-normal    ::= "\begin{MARKER}" text "\end{MARKER}"
  code-comment   ::= "% MARKER" text "% noMARKER"
  result-normal  ::= "\begin{result}" text "\end{result}"
  result-comment ::= "% result" text "% noresult"
  ignore         ::= "% ignore" text "% noignore"
  text           ::= ...
  \end{verbatim}
  \end{minipage}
  \caption{An illustrative grammar template for LaTeX documents where marker
  serves as a parameter configured via command-line arguments for each supported
  interpreter class.}
  \label{fig:document_representation}
\end{figure*}
%lnoignore

Litrepl abstracts documents as a straightforward sequence comprising code,
result, and text sections. Additionally, Litrepl identifies ignore blocks, which
act as comments that prevent enclosed sections from being evaluated.

Template grammars similar to the illustrative example above are encoded for
Markdown and LaTeX formats. Before each run, Litrepl calls Lark\cite{Lark} to
compile a customized parser and uses it to access the sections.

\section{Discussion}

TODO

\section{Conclusion}

The tool is implemented in Python in about 2K lines of code according to the LOC
metric, and has only two Python dependencies so far, at the cost of the
dependency on the operating system intefaces for which we choose POSIX as a
wide-spread openly available standard.

\printbibliography


\end{document}

