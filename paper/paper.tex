\documentclass[letterpaper,12pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{svg}
\usepackage{comment}
\usepackage{float}
\usepackage[font=small,skip=0pt]{caption}

\usepackage{biblatex}
\addbibresource{paper.bib}

\geometry{margin=1in}

\fancypagestyle{plain}{
  \fancyhf{}
  \lhead{Sergei Mironov}
  \rhead{Litrepl}
  \rfoot{\thepage}
}

\newcommand{\ls}{\begin{itemize}\item}
\newcommand{\li}{\item}
\renewcommand{\le}{\end{itemize}}

\newcommand{\es}{\begin{enumerate}\item}
\newcommand{\ei}{\item}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\Latex}{\LaTeX\ }

\pagestyle{plain}

\title{Litrepl: Literate Paper Processor Promoting Transparency More Than Reproducibility}
\author{Sergei Mironov \\
        \texttt{sergei.v.mironov@proton.me}}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}

Litrepl is a simple and lightweight text processing tool designed to recognize
and evaluate code sections within Markdown or \Latex documents. This
functionality is useful for both batch document section evaluation and
interactive coding within a text editor, provided a straightforward integration
is established.

\end{abstract}

\section{Statement of Need}

\begin{figure*}[!hbt]
  \centering
  \includesvg[inkscapelatex=false,width=0.8\textwidth]{pic}
  \caption{Litrepl resource allocation diagram. Hash \textbf{A} is computed
  based on the Litrepl working directory and the interpreter class. Hash
  \textbf{B} is computed based on the contents of the code section.}
  \label{fig:resource-allocation}
\end{figure*}

The concept of \textit{Literate Programming} was formulated by Donald Knuth,
suggesting a shift in focus from writing code to explaining to human beings what
we want a computer to do (\textcite{Knuth1984lp}). This approach is embodied in
the WEB system and its derived family of tools, which translate combined code
and narrative documents into human-readable documentation and machine-executable
code. Over time, the concept has evolved, showing a trend towards simplification
(\textcite{Ramsey1994lps}).

Concurrently, a concept of human-computer interaction often called the
\textit{Read-Evaluate-Print Loop} or ''REPL'' gained traction, notably within
the LISP an APL communities (\textcite{Spence1975apl},
\textcite{McCarthy1959recfun}, \textcite{Iverson1962apl}).

The combination of a command-line interface and a language interpreter enables
incremental and interactive programming, allowing users to directly modify the
interpreter state. By maintaining human involvement in the loop, this approach
is believed to facilitate human thought processes (\textcite{Granger2021litcomp}).

A significant milestone in this area became the IPython interpreter
(\textcite{Perez2007IPython}), which later evolved into the Jupyter Project. The
creators introduced a new document format called the Jupyter Notebook
(\textcite{Kluyver2016jupnb}), characterized by a series of logical sections of
various types, including text and code, which could directly interact with
programming language interpreters. This interactive communication, akin to REPL
style programming, allows the creation of well-structured documents suitable for
presentations and sharing. The concept underpinning these developments is termed
\textit{Literate Computing}\cite{Perez2015blog}, which includes goals of
spanning a wide audience range, boosting reproducibility, and fostering
collaboration. To achieve these objectives, several technical decisions were
made, notably the introduction of bidirectional communication between the
computational core, known as the Jupyter Kernel, and the Notebook web-based
renderer, along with another layer of client-server communication between the
renderer and the userâ€™s web browser.

While we recognize the importance of all goals within the Literate Computing
framework, we argue that the goal of reproducibility is paramount. Successfully
addressing reproducibility would alone suffice to enhance communication over the
time and space separated researchers and significantly expand the audience.
However, as it became clear (\textcite{Dolstra2010}), this challenge extends
beyond the scope of a single human-computer interaction system, and even beyond
the typical boundaries of software distribution management for a particular
programming language. A comprehensive solution to the software deployment
problem should operate at the entire operating system level.

Following \textcite{Vallet2022}, we suggest changing the focus of human-computer
interaction towards simplicity and transparency. We saw an opportunity to
implement a tool that would offer familiar REPL-style editing, be compatible
with existing code editors and text formats, thus maintaining familiar editing
practices, and have a gradually smaller codebase.

We introduce \textit{Litrepl}, a processor designed to achieve these goals
through several means. First, we employ straightforward bidirectional text
streams for inter-process communication with language interpreters to evaluate
code.  Second, we advocate for the reuse of existing text document formats. In
both the Markdown and \Latex evaluators that we have implemented, simplified
parsers are utilized to distinguish code and result sections from the rest of
the document.  As of now, we support Python and Shell interpreter families, as
well as a custom large language model communication interpreter. Finally, we
strive to leverage POSIX\cite{POSIX2024} operating system facilities as much as
possible.

\section{How it works}

Litrepl is implemented as a command-line text processor utility. Its primary
function is to take a text document as input, process it according to specified
command line arguments and environment settings, and then output the resulting
document through its standard output.

The operation of Litrepl is best illustrated through the example below. Consider
the document named \verb|input.tex|:

\begin{comment}
\begin{sh}
echo '\begin{verbatim}'
echo '$ cat input.tex'
cat input.tex
echo '\end{verbatim}'
\end{sh}
\end{comment}
%lresult
\begin{verbatim}
$ cat input.tex
\begin{python}
import sys
print(f"I use {sys.platform} btw!")
\end{python}
\begin{result}
\end{result}
\end{verbatim}
%lnoresult

This document contains a Python code section and an empty result section marked
with the corresponding \Latex environment tags. To "execute" the document we
pipe it though the Litrepl processor as follows:

\begin{comment}
\begin{sh}
echo '\begin{verbatim}'
echo '$ cat input.tex | litrepl'
echo "sys.platform='linux'" | litrepl repl python >/dev/null
cat input.tex | litrepl
echo '\end{verbatim}'
\end{sh}
\end{comment}
%lresult
\begin{verbatim}
$ cat input.tex | litrepl
\begin{python}
import sys
print(f"I use {sys.platform} btw!")
\end{python}
\begin{result}
I use linux btw!
\end{result}
\end{verbatim}
%lnoresult

Now we can see the expected statement about the author's operating system.  The
side-effect of this execution is the started session of the python interpreter
which is now running in the background. We can modify its state by adding more
section to the document and executing them selectively or e.g. by accessing
\verb|litrepl repl python| terminal. So for example, setting \verb|sys.platform|
to another value and re-evaluating the document would yield a different
statement.


\subsection{Interfacing Interpreters}

Litrepl communicates with interpreters using two uni-directional text streams:
one for writing input and another for reading outputs. To establish effective
communication, the interpreter should conform to the following general
assumptions:

\begin{itemize}
  \item Synchronous single-user mode, which is implemented in most interpreters.
  \item A capability to disable command line prompts. Litrepl relies on the echo
        response, as described below, rather than on prompt detection.
  \item The presence of an echo command or equivalent. The interpreter must be
        able to echo an argument string provided by the user in response to the
        echo command.
\end{itemize}

In Litrepl, these details are hardcoded for several prominent interpreter
families, which we refer to as \textit{interpreter classes}. At the time of
writing, Litrepl supports three such classes: \textbf{python}, \textbf{sh}, and
\textbf{ai}. Using command line arguments, users can configure how to map code
section labels to the correct class and specify which interpreter command to
execute to start a session for each class.

\subsection{Session Management}

\begin{comment}
\begin{sh}
echo -n '\begin' ; echo '{verbatim}'
echo '\begin{result}'
litrepl --python-auxdir=/tmp/litrepl/python restart python
{
cat <<EOF
import time
print('... some output ...')
time.sleep(9999)
EOF
}|litrepl --python-auxdir=/tmp/litrepl/python --timeout=1,inf eval-code python
echo '\end{result}'
echo -n '\end'; echo '{verbatim}'
\end{sh}
\end{comment}

\begin{figure*}[hbt!]
  \centering
  \begin{minipage}{\textwidth}
  %lresult
  \begin{verbatim}
  \begin{result}
  ... some output ...
  [LR:/tmp/litrepl/python/partial_7b81e1e.txt]
  \end{result}
  \end{verbatim}
  %lnoresult
  \end{minipage}
  \caption{Example output in a verbatim format displayed above two columns.}
  \label{fig:partial-result}
\end{figure*}

\begin{comment}
%lai
Lets rewrite the "Session management" section. Please consider the following
points, check the grammar and combine them into a linked narrative. Please
generate it using Latex markup. Wrap your own comments in Latex line comments.
Please don't generate figures. Just text.

----

1. As mentioned earlier, the necessary side-effect of code section evaluation,
which makes read-eval loop possible - is the the interpreter session left
running in the background. The resources required to manage this mode of
operation are shown on the Figure \ref{fig:resource-allocation}. All of them are
visible as files residing in some auxiliary directory.

2. If not set via arguments or environment, the path to this directory
is calculated out of interpreter class name, current working directory and the
operating system temporary folder name.

3. The code to be evaluated determines (via hashing) the name of the response file,
containing interpreter response for this code.

4. Also, aux. dir contains a couple of pipes providing an access to the
interpreter standard input and ouput streams.

5. Finally, the PID of the interpreter process is also stored in a file.

6. When evaluating, Litrepl forks a response reader which keeps it soft-locked
until the interpreter signals the completion by answering to the echo probe. If
the response takes longer than configured, Litrepl outputs a pratial response
result which can be read and checked for completion during next runs.

7. Litrepl provides \textbf{start}, \textbf{stop}, \textbf{restart} commands
accepting the name of interpreter class to act on to start, stop or restart
interpreter sessions.

----

%lnoai
\end{comment}

%lresult
Litrepl's ability to maintain interpreter sessions in the background is crucial
for enabling a Read-Eval-Print Loop (REPL) environment. The associated
resources, shown in Figure \ref{fig:resource-allocation}, are stored as files
within an auxiliary directory.

If not specified by command-line arguments or environment variables, the
directory path is automatically derived from the interpreter class name, the
current working directory, and the OS's temporary file location.

The auxiliary directory includes two POSIX pipes for interpreter I/O and a file
recording the running interpreter's process ID, aiding session management.

When a code section is evaluated, Litrepl assigns a response file name derived
from hashing the code. This response file stores the output from the
interpreter.

During evaluation, Litrepl spawns a response reader process with a soft lock,
active until the interpreter completes and responds to an echo probe. If the
response exceeds the configured duration, Litrepl outputs a partial result tag,
which is recognized and reevaluated in subsequent runs. Figure
\ref{fig:partial-result} shows an example partial result section.

Litrepl provides \textbf{start}, \textbf{stop}, and \textbf{restart} commands to
control background sessions. The \textbf{interrupt} command sends an
interruption signal to the interpreter. Finally, the \textbf{repl} command
establishes direct communication with the interpreter, allowing manual
inspection of its state.
%lnoresult

\subsection{Parsing and Evaluation}

%% ignore %%
\begin{figure*}[hbt!]
  \centering
  \begin{minipage}{\textwidth}
  \begin{verbatim}
  document       ::= (code | result | ignore | text)*
  code           ::= (code-normal | code-comment)
  result         ::= (result-normal | result-comment)
  code-normal    ::= "\begin{MARKER}" text "\end{MARKER}"
  code-comment   ::= "% MARKER" text "% noMARKER"
  result-normal  ::= "\begin{result}" text "\end{result}"
  result-comment ::= "% result" text "% noresult"
  ignore         ::= "% ignore" text "% noignore"
  text           ::= ...
  \end{verbatim}
  \end{minipage}
  \caption{An illustrative grammar template for \Latex documents where marker
  serves as a parameter configured via command-line arguments for each supported
  interpreter class.}
  \label{fig:document-representation}
\end{figure*}
%% noignore %%

Litrepl abstracts documents as a straightforward sequence comprising code,
result, and text sections. Additionally, Litrepl identifies ignore blocks, which
act as comments that prevent enclosed sections from being evaluated.

Template grammars similar to the illustrative example in Figure
\ref{fig:document-representation} are encoded for Markdown and \Latex formats.
Before each run, Litrepl calls Lark\textcite{Lark} to compile a customized
parser and uses it to access the sections.

Evaluation results are encoded back into the result sections, and the entire
document is printed. At this stage, certain conditions can be optionally
checked. First, setting \verb|--pending-exitcode| to a non-zero value instructs
Litrepl to report an error if a section takes longer than the timeout to
evaluate. Second, setting \verb|--exception-exitcode| directs Litrepl to detect
Python exceptions. Lastly, \verb|--irreproducible-exitcode| triggers an error if
the evaluation result doesn't match the text initially present in the result
section.

The last option implements the only formal check for aiding reproducibility that
Litrepl provides.

\section{Discussion}

\begin{comment}
% lai

Lets write the "Discussion" section. of the paper. Please check the grammar of
the following points and make a linked narrative out of them. Please use Latex
markup.

---

The technical decision to abstract interpreters using text streams has its
positive and negative sides. While simplicity is the obvious bonus, the negatvie
consequences can be groouped into (1) No parallel evaluation at the
communication level. Th interpreter gets locked until it finishes evaluation of
one snippet before it can proceed to another one. (2) Transferrable data type is
limited to text-only streams.

We argue that the lack of parallel execution at the communication level can be
compensated by using interpreter-specific parallelism where and if it is
supported. For example, Python programs can use all sort of subprocess
utilities while shell programs have full access to shell job control.

Restricting streams to text-only data type seems to be a more funcdamental
limitation. Litrepl lifts this limitation by supporting text-only document
formats. Both Latex and Markdown have means of including rich data but they
don't encode these data directly. Instead they rely on side channels: file
system or network for referring such objects. Litrepl shares both pros such as
good representation in well-known version control systems, and cons, e.g.
requirement to organize such a side-channel data transfer explicitly.

Another controversial technical solution - to transfer the whole document at
input and output - can have performance penalties. In our experience the system
works sufficienlty good for few-thousand line documents, but for larger
documents delays might become uncomfortable even on modern computers. Still we
prefer to keep this interface to make editor integration as simple as possible:
typical plugin can just pipe the whole document through the tool using few lines
of code.

In addition, we allow a more performant integrations which take responsibility
for pre-parsing and piping only the relevant parts of the document. For these
approach, Litrepl offers \verb|print-regexp| command printing the anchor regexp
in a few common formats.
% lnoai
\end{comment}

% lresult
The technical decision to abstract interpreters using text streams comes with
both advantages and disadvantages. A key advantage is simplicity. However, there
are notable negative aspects. Firstly, there is no parallel evaluation at the
communication level, meaning the interpreter is locked until it completes the
evaluation of one snippet before proceeding to the next. Secondly, the
transferable data type is restricted to text-only streams.

We argue that the lack of parallel execution at the communication level can be
mitigated using interpreter-specific parallelism, where supported. For instance,
Python programs can utilize various subprocess utilities, while shell programs
have full access to shell job control.

The restriction to text-only data types presents a more fundamental limitation.
Litrepl lifts this restriction by supporting text-only document formats. Both
\Latex and Markdown incorporate rich data without encoding it directly, instead
relying on side channels, such as the file system or network, to refer to such
objects. Consequently, Litrepl shares the advantages of good representation in
well-known version control systems, and the disadvantages, such as the need to
explicitly organize side-channel data transfer.

Another controversial technical decision is transferring the entire document as
input and output, which can negatively impact performance. Our experience shows
that the system performs adequately for documents of a few thousand lines.
However, larger documents may experience uncomfortable delays, even on modern
computers. Despite this, we choose to maintain this interface because it
simplifies editor integration. A typical plugin can pipe the whole document
through the tool using just a few lines of code.

Moreover, we support more performance-oriented integrations that handle
pre-parsing and piping only relevant document parts. For these approaches,
Litrepl offers the \verb|print-regexp| command, which outputs the anchor regexp
in several common formats.
% lnoresult

\section{Conclusion}

The tool is implemented in Python in about 2K lines of code according to the LOC
metric, and has only two Python dependencies so far, at the cost of the
dependency on the operating system interfaces for which we choose POSIX as a
widespread openly available standard. Needless to say, we used Litrepl to
evaluate and verify the examples presented in this document.

\printbibliography


\end{document}

