{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Litrepl Litrepl is a command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style. The repository includes a Vim plugin to demonstrate editor integration.","title":"Home"},{"location":"#litrepl","text":"Litrepl is a command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style. The repository includes a Vim plugin to demonstrate editor integration.","title":"Litrepl"},{"location":"coverage/","text":"Coverage report !coverage report --format=markdown -m No data to report.","title":"Coverage"},{"location":"coverage/#coverage-report","text":"!coverage report --format=markdown -m No data to report.","title":"Coverage report"},{"location":"development/","text":"Development Litrepl uses Nix as its main development framework. The file flake.nix manages the source-level dependencies required by Nix, whereas default.nix specifies common build targets, including PyPI and Vim packages, demo Vim configurations, development shells, and more. Building Targets To build individual Nix expressions, execute the command nix build '.#NAME' , replacing NAME with the actual name of the Nix expression you want to build. If the build is successful, Nix places the results of the last build in a symbolic link located at ./result . For example, to build a version of Vim pre-configured for demo, run $ nix build '.#vim-demo' $ ./result/bin/vim-demo # Run the pre-configured demo instance of Vim The list of Nix build targets includes: litrepl-release - Litrepl script and Python lib litrepl-release-pypi - Litrepl script and Python lib vim-litrepl-release - Vim with locally built litrepl plugin vim-litrepl-release-pypi - Vim with litrepl plugin built from PYPI vim-test - A minimalistic Vim with a single litrepl plugin vim-demo - Vim configured to use litrepl suitable for recording screencasts vim-plug - Vim configured to use litrepl via the Plug manager shell-dev - The development shell shell-screencast - The shell for recording demonstrations, includes vim-demo . See local.collection attribute-set in the default.nix for the full list of defined targetr. Development Environments and Setup The default development shell is defined in the ./default.nix as a Nix expression named shell which is the default name for development shells. Running $ nix develop will ask Nix to install the development dependencies and open shell. Testing The runtests.sh script runs all tests by default, but accepts command-line arguments for running specific tests. Note, that Litrepl distinguishes the Python interpreter use to run the litrepl script ( -p argument) from the Python interpreters used to run the code sections ( -i argument). By default, ./runtest.sh runs the litrepl script with the python interpreter (whatever it is, leaving the OS to decide) and iterates over all visible Python interpreters for running code sections. [ LitREPL-DEV ] $ runtests.sh --help Usage: runtest.sh [-d] [-i I(,I)*] [-t T(,T)*] Arguments: -d Be very verbose -i I, --interpreters=I Run tests requiring interpreters matching the grep expression I Run -i '?' to list all available interpreters -t T, --tests=T Run tests whose names match the grep expression T Run -t '?' to list all available tests -p P, --python=P Use this Python interpreter to run Litrepl Run -p '?' to list available python interpreters -c FILE, --coverage=FILE Collect coverage results into the FILE. Defaults to `.coverage` if no tests or interpreters are selected, otherwize disabled. -c -, --coverage=- Disable coverage. Examples: runtests.sh -t '?' -i '?' runtests.sh -i ipython runtests.sh -t 'test_eval_code|test_status' -i python Coverage Coverage is performed after the full testing cycle. The latest coverage report is available . Tools for Screencast Recording Another shell which might be useful is shell-screencast . This would build the full set of Litrepl tools and makes sure that the screencasting software is available. To enter it, specify its Nix-flake path as follows: $ nix develop '.#shell-screencast' In the opened shell, run the screencast.sh and wait a second, until the script arranges demo and recorder wondows. $ screencast.sh screencast.sh accepts an optional parameter specifying the template file to open for the recording session. Other Development Scenarios The top-level Makefile encodes common development scenarios: [ LitREPL-DEV ] $ make help LitREPL is a macroprocessing Python library for Litrate programming and code execution Build targets: dist: Build Python and Vim packages docs: Build the MkDocs documentation examples: Build examples help: Print help man: Build a manpage paper-quick: Compile the paper PDF out of its LaTeX source without re-evaluation paper: Check and compile the paper PDF out of its LaTeX source readme: Update code sections in the README.md test-small: Run tests script using just the current Python and Shell interpreters test: Run tests script using all available interpreters upload: Upload Python wheel to Pypi.org (./_token.pypi is required) version: Print the version vimbundle: Build Vim bundle wheel: Build Python wheel (the DEFAULT target) Github CI The .github/workflows/testing.yaml rule set instructs Github CI to run the set of test-small tests for some versions of Python interpreter. The badge on the main page highlightes the CI status. Technical Insights The following events should normally happen after users type the :LitEval1 command: On the first run, LitREPL starts the Python interpreter in the background. Its standard input and output are redirected into UNIX pipes in the current directory. LitREPL runs the whole document through the express Markdown/Latex parser determining the start/stop positions of code and result sections. The cursor position is also available and the code from the right code section can reach the interpreter. The process which reads the interpreter's response is forked out of the main LitREPL process. The output goes to the temporary file. If the interpreter reports the completion quickly, the output is pasted to the resulting document immediately. Otherwise, the temporary results are pasted. Re-evaluating sections with temporary results causes LitREPL to update these results. Known Limitations Formatting: Nested code sections are not supported. ~~Formatting: Special symbols in the Python output could invalidate the document~~. Interpreter: Extra newline is required after Python function definitions. Interpreter: Stdout and stderr are joined together. ~~Interpreter: Evaluation of a code section locks the editor~~. Interpreter: Tweaking os.ps1 / os.ps2 prompts of the Python interpreter could break the session. ~~Interpreter: No asynchronous code execution.~~ ~~Interpreter: Background Python interpreter couldn't be interrupted~~ ~~ Bad PDF fonts in Firefox ~~","title":"Development"},{"location":"development/#development","text":"Litrepl uses Nix as its main development framework. The file flake.nix manages the source-level dependencies required by Nix, whereas default.nix specifies common build targets, including PyPI and Vim packages, demo Vim configurations, development shells, and more.","title":"Development"},{"location":"development/#building-targets","text":"To build individual Nix expressions, execute the command nix build '.#NAME' , replacing NAME with the actual name of the Nix expression you want to build. If the build is successful, Nix places the results of the last build in a symbolic link located at ./result . For example, to build a version of Vim pre-configured for demo, run $ nix build '.#vim-demo' $ ./result/bin/vim-demo # Run the pre-configured demo instance of Vim The list of Nix build targets includes: litrepl-release - Litrepl script and Python lib litrepl-release-pypi - Litrepl script and Python lib vim-litrepl-release - Vim with locally built litrepl plugin vim-litrepl-release-pypi - Vim with litrepl plugin built from PYPI vim-test - A minimalistic Vim with a single litrepl plugin vim-demo - Vim configured to use litrepl suitable for recording screencasts vim-plug - Vim configured to use litrepl via the Plug manager shell-dev - The development shell shell-screencast - The shell for recording demonstrations, includes vim-demo . See local.collection attribute-set in the default.nix for the full list of defined targetr.","title":"Building Targets"},{"location":"development/#development-environments-and-setup","text":"The default development shell is defined in the ./default.nix as a Nix expression named shell which is the default name for development shells. Running $ nix develop will ask Nix to install the development dependencies and open shell.","title":"Development Environments and Setup"},{"location":"development/#testing","text":"The runtests.sh script runs all tests by default, but accepts command-line arguments for running specific tests. Note, that Litrepl distinguishes the Python interpreter use to run the litrepl script ( -p argument) from the Python interpreters used to run the code sections ( -i argument). By default, ./runtest.sh runs the litrepl script with the python interpreter (whatever it is, leaving the OS to decide) and iterates over all visible Python interpreters for running code sections. [ LitREPL-DEV ] $ runtests.sh --help Usage: runtest.sh [-d] [-i I(,I)*] [-t T(,T)*] Arguments: -d Be very verbose -i I, --interpreters=I Run tests requiring interpreters matching the grep expression I Run -i '?' to list all available interpreters -t T, --tests=T Run tests whose names match the grep expression T Run -t '?' to list all available tests -p P, --python=P Use this Python interpreter to run Litrepl Run -p '?' to list available python interpreters -c FILE, --coverage=FILE Collect coverage results into the FILE. Defaults to `.coverage` if no tests or interpreters are selected, otherwize disabled. -c -, --coverage=- Disable coverage. Examples: runtests.sh -t '?' -i '?' runtests.sh -i ipython runtests.sh -t 'test_eval_code|test_status' -i python","title":"Testing"},{"location":"development/#coverage","text":"Coverage is performed after the full testing cycle. The latest coverage report is available .","title":"Coverage"},{"location":"development/#tools-for-screencast-recording","text":"Another shell which might be useful is shell-screencast . This would build the full set of Litrepl tools and makes sure that the screencasting software is available. To enter it, specify its Nix-flake path as follows: $ nix develop '.#shell-screencast' In the opened shell, run the screencast.sh and wait a second, until the script arranges demo and recorder wondows. $ screencast.sh screencast.sh accepts an optional parameter specifying the template file to open for the recording session.","title":"Tools for Screencast Recording"},{"location":"development/#other-development-scenarios","text":"The top-level Makefile encodes common development scenarios: [ LitREPL-DEV ] $ make help LitREPL is a macroprocessing Python library for Litrate programming and code execution Build targets: dist: Build Python and Vim packages docs: Build the MkDocs documentation examples: Build examples help: Print help man: Build a manpage paper-quick: Compile the paper PDF out of its LaTeX source without re-evaluation paper: Check and compile the paper PDF out of its LaTeX source readme: Update code sections in the README.md test-small: Run tests script using just the current Python and Shell interpreters test: Run tests script using all available interpreters upload: Upload Python wheel to Pypi.org (./_token.pypi is required) version: Print the version vimbundle: Build Vim bundle wheel: Build Python wheel (the DEFAULT target)","title":"Other Development Scenarios"},{"location":"development/#github-ci","text":"The .github/workflows/testing.yaml rule set instructs Github CI to run the set of test-small tests for some versions of Python interpreter. The badge on the main page highlightes the CI status.","title":"Github CI"},{"location":"development/#technical-insights","text":"The following events should normally happen after users type the :LitEval1 command: On the first run, LitREPL starts the Python interpreter in the background. Its standard input and output are redirected into UNIX pipes in the current directory. LitREPL runs the whole document through the express Markdown/Latex parser determining the start/stop positions of code and result sections. The cursor position is also available and the code from the right code section can reach the interpreter. The process which reads the interpreter's response is forked out of the main LitREPL process. The output goes to the temporary file. If the interpreter reports the completion quickly, the output is pasted to the resulting document immediately. Otherwise, the temporary results are pasted. Re-evaluating sections with temporary results causes LitREPL to update these results.","title":"Technical Insights"},{"location":"development/#known-limitations","text":"Formatting: Nested code sections are not supported. ~~Formatting: Special symbols in the Python output could invalidate the document~~. Interpreter: Extra newline is required after Python function definitions. Interpreter: Stdout and stderr are joined together. ~~Interpreter: Evaluation of a code section locks the editor~~. Interpreter: Tweaking os.ps1 / os.ps2 prompts of the Python interpreter could break the session. ~~Interpreter: No asynchronous code execution.~~ ~~Interpreter: Background Python interpreter couldn't be interrupted~~ ~~ Bad PDF fonts in Firefox ~~","title":"Known Limitations"},{"location":"installation/","text":"Installation The Github repository hosts the Litrepl tool, a standalone command-line application and an interface plugin for the Vim editor. The author's preferred installation method is using Nix, but if you choose not to use it, you'll need to install one or both components separately. Below, we outline several common installation methods. Installing release versions from Pypi and Vim.org pip install litrepl Download the latest vim-litrepl-*.tar.gz from the vim.org script page and unpack it into your ~/.vim folder with tar -xf vim-litrepl-*.tar.gz -C ~/.vim Optionally, install the socat tool using your system package manager. Installing latest versions from Git using Pip and Vim-Plug Install the litrepl Python package with pip: sh $ pip install --user git+https://github.com/sergei-mironov/litrepl $ litrepl --version Install the Vim plugin by adding the following line between the plug#begin and plug#end lines of your .vimrc file: vim Plug 'https://github.com/sergei-mironov/litrepl' , { 'rtp': 'vim' } Note: rtp sets the custom vim-plugin source directory of the plugin. Optionally, install the socat tool using your system package manager. Installing latest versions from source using Nix The repository offers a suite of Nix expressions designed to optimize installation and development processes on systems that support Nix. Consistent with standard practices in Nix projects, the flake.nix file defines the source dependencies, while the default.nix file identifies the build targets. For testing, the vim-demo expression is a practical choice. It includes a pre-configured Vim setup with several related plugins, including Litrepl. To build this target, use the command nix build '.#vim-demo' . Once the build is complete, you can run the editor with ./result/bin/vim-demo . To add the Litrepl tool to your system profile, first include the Litrepl flake in your flake inputs. Then, add litrepl-release to environment.systemPackages or to your custom environment. To include the Litrepl Vim plugin, add vim-litrepl-release to the vimPlugins list within your vim_configurable expression. Regardless of the approach, Nix will manage all necessary dependencies automatically. Nix are used to open the development shell, see the Development section. Installing latest versions from source using Pip The Litrepl application might be installed with pip install . run from the project root folder. The Vim plugin part requires hand-copying ./vim/plugin/litrepl.vim and ./vim/plugin/litrepl_extras.vim to the ~/.vim config folder. Notes Optional Socat tool The Nix-powered installation methods install the Socat tool automatically. For other installation methods, use your system package manager to install it. For example, Ubuntu users might run sudo apt-get install socat . Python interpreters The Python interpreter is usually installed by default, along with the pip installer. To install ipython , you can use pip install ipython . Aicli interpreter A GNU Readline-based application for interacting with chat-oriented AI models, which Litrep supports as the interpret for ai code sections. For the details, please check the aicli project page. Typically, you can install it with pip install sm_aicli .","title":"Installation"},{"location":"installation/#installation","text":"The Github repository hosts the Litrepl tool, a standalone command-line application and an interface plugin for the Vim editor. The author's preferred installation method is using Nix, but if you choose not to use it, you'll need to install one or both components separately. Below, we outline several common installation methods.","title":"Installation"},{"location":"installation/#installing-release-versions-from-pypi-and-vimorg","text":"pip install litrepl Download the latest vim-litrepl-*.tar.gz from the vim.org script page and unpack it into your ~/.vim folder with tar -xf vim-litrepl-*.tar.gz -C ~/.vim Optionally, install the socat tool using your system package manager.","title":"Installing release versions from Pypi and Vim.org"},{"location":"installation/#installing-latest-versions-from-git-using-pip-and-vim-plug","text":"Install the litrepl Python package with pip: sh $ pip install --user git+https://github.com/sergei-mironov/litrepl $ litrepl --version Install the Vim plugin by adding the following line between the plug#begin and plug#end lines of your .vimrc file: vim Plug 'https://github.com/sergei-mironov/litrepl' , { 'rtp': 'vim' } Note: rtp sets the custom vim-plugin source directory of the plugin. Optionally, install the socat tool using your system package manager.","title":"Installing latest versions from Git using Pip and Vim-Plug"},{"location":"installation/#installing-latest-versions-from-source-using-nix","text":"The repository offers a suite of Nix expressions designed to optimize installation and development processes on systems that support Nix. Consistent with standard practices in Nix projects, the flake.nix file defines the source dependencies, while the default.nix file identifies the build targets. For testing, the vim-demo expression is a practical choice. It includes a pre-configured Vim setup with several related plugins, including Litrepl. To build this target, use the command nix build '.#vim-demo' . Once the build is complete, you can run the editor with ./result/bin/vim-demo . To add the Litrepl tool to your system profile, first include the Litrepl flake in your flake inputs. Then, add litrepl-release to environment.systemPackages or to your custom environment. To include the Litrepl Vim plugin, add vim-litrepl-release to the vimPlugins list within your vim_configurable expression. Regardless of the approach, Nix will manage all necessary dependencies automatically. Nix are used to open the development shell, see the Development section.","title":"Installing latest versions from source using Nix"},{"location":"installation/#installing-latest-versions-from-source-using-pip","text":"The Litrepl application might be installed with pip install . run from the project root folder. The Vim plugin part requires hand-copying ./vim/plugin/litrepl.vim and ./vim/plugin/litrepl_extras.vim to the ~/.vim config folder.","title":"Installing latest versions from source using Pip"},{"location":"installation/#notes","text":"","title":"Notes"},{"location":"installation/#optional-socat-tool","text":"The Nix-powered installation methods install the Socat tool automatically. For other installation methods, use your system package manager to install it. For example, Ubuntu users might run sudo apt-get install socat .","title":"Optional Socat tool"},{"location":"installation/#python-interpreters","text":"The Python interpreter is usually installed by default, along with the pip installer. To install ipython , you can use pip install ipython .","title":"Python interpreters"},{"location":"installation/#aicli-interpreter","text":"A GNU Readline-based application for interacting with chat-oriented AI models, which Litrep supports as the interpret for ai code sections. For the details, please check the aicli project page. Typically, you can install it with pip install sm_aicli .","title":"Aicli interpreter"},{"location":"reference/","text":"Command Reference Vim Commands and Command-Line Attributes Vim Command line Description :LStart [T] litrepl start [T] Start the background interpreter :LStop [T] litrepl stop [T] Stop the background interpreter :LRestart [T] litrepl restart [T] Restart the background interpreter :LStatus [T] litrepl status [T] <F Print the background interpreter status :LEval [N] lirtepl eval-sections L:C <F Evaluate the section under the cursor synchronously :LEval above lirtepl eval-sections '0..N' <F Evaluate sections above and under the cursor synchronously :LEval below lirtepl eval-sections 'N..$' <F Evaluate sections below and under the cursor synchronously :LEval all lirtepl eval-sections <F Evaluate all code sections in a document :LEvalAsync N lirtepl --timeout=0.5,0 eval-sections N <F Start or continue asynchronous evaluation of the section under the cursor :LInterrupt N lirtepl interrupt N <F Send SIGINT to the interpreter evaluating the section under the cursor and update :LEvalMon N while .. do .. done Start or continue monitoring asynchronous code evaluation N/A lirtepl eval-code <P Evaluate the given code verbatim :LTerm [T] lirtepl repl [T] Connect to the interpreter using GNU socat :LOpenErr litrepl ... 2>F View errors :LVersion litrepl --version Show version Where T Type of the interpreter: python , ai or sh (some commands also accept all ) F Path to a Markdown or LaTeX file P Path to a Python script N Number of code section to evaluate, starting from 0. L:C denotes line:column of the cursor. Command Line Arguments and Vim Variables Vim setting CLI argument Description set filetype --filetype=T Input file type: latex | markdown let g:litrepl_python_interpreter=B --python-interpreter=B The Python interpreter to use let g:litrepl_ai_interpreter=B --ai-interpreter=B The AI interpreter to use let g:litrepl_sh_interpreter=B --sh-interpreter=B The shell interpreter to use let g:litrepl_python_auxdir=D --python-auxdir=D The auxiliary files directory used by Python interpreter let g:litrepl_ai_auxdir=D --ai-auxdir=D The auxiliary files directory used by AI interpreter let g:litrepl_sh_auxdir=D --sh-auxdir=D The auxiliary files directory used by a shell interpreter let g:litrepl_workdir=D --workdir=D The auxiliary files directory used by AI interpreter let g:litrepl_debug=0/1 --debug=0/1 Print debug messages to the stderr let g:litrepl_timeout=FLOAT --timeout=FLOAT Timeout to wait for the new executions, in seconds, defaults to inf T Type of the document: tex or markdown (the default). B Interpreter command to use, - or auto (the default). - value disabled this type of interpreters; auto asks litrep to guess the best available interpreter. D Filesystem directory FLOAT Should be formatted as 1 or 1.1 or inf . Note: command line argument also accepts a pair of timeouts. Command Line Arguments Summary usage: litrepl [-h] [-v] [--filetype STR] [--python-markers STR[,STR]] [--ai-markers STR[,STR]] [--sh-markers STR[,STR]] [--python-interpreter EXE] [--ai-interpreter EXE] [--sh-interpreter EXE] [--python-auxdir DIR] [--ai-auxdir DIR] [--sh-auxdir DIR] [--timeout F[,F]] [--propagate-sigint] [-d INT] [--verbose] [-C DIR] [--pending-exitcode INT] [--irreproducible-exitcode INT] [--exception-exitcode INT] [--foreground] [--map-cursor LINE:COL:FILE] [--result-textwidth NUM] {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} ... positional arguments: {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} Commands to execute start Start a background interpreter. The CLASS of an interpreter should be specified. --<CLASS>-interpreter, --<CLASS>-auxdir etc. are applied. stop Stop the background interpreters. restart Restart the background interpreters. status Print background interpreter's status. parse Parse the input file without futher processing (diagnostics). parse-print Parse and print the input file back (diagnostics). eval-sections Parse stdin, evaluate the specified sections (by default - all available sections), print the resulting file to stdout. eval-code Evaluate the code snippet. repl Connect to the background terminal using GNU socat. interrupt Send SIGINT to the background interpreter. print-regexp Print regexp matching start of code sections for the given file type. print-grammar Print the resulting grammar for the given filetype. print-auxdir Print the auxdir for the given interpreter type. options: -h, --help show this help message and exit -v, --version Print version. --filetype STR Specify the type of input formatting (markdown|[la]tex|auto). --python-markers STR[,STR] Specify section markers recognized as `python` sections. Defaults to the value of LITREPL_PYTHON_MARERS if set, otherwize \"python\". --ai-markers STR[,STR] Specify section markers recognized as `ai` sections. Defaults to the value of LITREPL_AI_MARERS if set, otherwize \"codeai,ai\". --sh-markers STR[,STR] Specify section markers recognized as `shell` sections. Defaults to the value of LITREPL_SH_MARERS if set, otherwize \"shell\". --python-interpreter EXE Python interpreter command line, or `auto`. Defaults to the LITREPL_PYTHON_INTERPRETER environment variable if set, otherwise \"auto\". Litrepl determines \"python\" or \"ipython\" type according to the value. --ai-interpreter EXE `aicli` interpreter command line or `auto`. Defaults to the LITREPL_AI_INTERPRETER environment variable if set, otherwise \"auto\". --sh-interpreter EXE Shell interpreter command line or `auto`. Defaults to the LITREPL_SH_INTERPRETER environment variable if set, otherwise \"auto\". --python-auxdir DIR This directory stores Python interpreter pipes. It defaults to LITREPL_PYTHON_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --ai-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_AI_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --sh-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_SH_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --timeout F[,F] Timeouts for initial evaluation and for pending checks, in seconds. If the latter is omitted, it is considered to be equal to the former one. --propagate-sigint If set, litrepl will catch and resend SIGINT signals to the running interpreter. Otherwise it will just terminate itself leaving the interpreter as-is. -d INT, --debug INT Enable (a lot of) debug messages. --verbose Be more verbose (used in status). -C DIR, --workdir DIR Set the working directory before execution. By default, it uses LITREPL_WORKDIR if set, otherwise remains the current directory. This affects the directory of a new interpreter and the --<interpreter>-auxdir option. --pending-exitcode INT Return this error code if whenever a section hits timeout. --irreproducible-exitcode INT Return this error code if a section outputs a different result than the one that is already present in the document. --exception-exitcode INT Return this error code at exception, if any. Note: this option might not be defined for some interpreters. It takes affect only for newly- started interpreters. --foreground Start a separate session and stop it when the evaluation is done. All --*-auxdir settings are ignored in this mode. --map-cursor LINE:COL:FILE Calculate the new position of a cursor at LINE:COL and write it to FILE. --result-textwidth NUM Wrap result lines longer than NUM symbols.","title":"Reference"},{"location":"reference/#command-reference","text":"","title":"Command Reference"},{"location":"reference/#vim-commands-and-command-line-attributes","text":"Vim Command line Description :LStart [T] litrepl start [T] Start the background interpreter :LStop [T] litrepl stop [T] Stop the background interpreter :LRestart [T] litrepl restart [T] Restart the background interpreter :LStatus [T] litrepl status [T] <F Print the background interpreter status :LEval [N] lirtepl eval-sections L:C <F Evaluate the section under the cursor synchronously :LEval above lirtepl eval-sections '0..N' <F Evaluate sections above and under the cursor synchronously :LEval below lirtepl eval-sections 'N..$' <F Evaluate sections below and under the cursor synchronously :LEval all lirtepl eval-sections <F Evaluate all code sections in a document :LEvalAsync N lirtepl --timeout=0.5,0 eval-sections N <F Start or continue asynchronous evaluation of the section under the cursor :LInterrupt N lirtepl interrupt N <F Send SIGINT to the interpreter evaluating the section under the cursor and update :LEvalMon N while .. do .. done Start or continue monitoring asynchronous code evaluation N/A lirtepl eval-code <P Evaluate the given code verbatim :LTerm [T] lirtepl repl [T] Connect to the interpreter using GNU socat :LOpenErr litrepl ... 2>F View errors :LVersion litrepl --version Show version Where T Type of the interpreter: python , ai or sh (some commands also accept all ) F Path to a Markdown or LaTeX file P Path to a Python script N Number of code section to evaluate, starting from 0. L:C denotes line:column of the cursor.","title":"Vim Commands and Command-Line Attributes"},{"location":"reference/#command-line-arguments-and-vim-variables","text":"Vim setting CLI argument Description set filetype --filetype=T Input file type: latex | markdown let g:litrepl_python_interpreter=B --python-interpreter=B The Python interpreter to use let g:litrepl_ai_interpreter=B --ai-interpreter=B The AI interpreter to use let g:litrepl_sh_interpreter=B --sh-interpreter=B The shell interpreter to use let g:litrepl_python_auxdir=D --python-auxdir=D The auxiliary files directory used by Python interpreter let g:litrepl_ai_auxdir=D --ai-auxdir=D The auxiliary files directory used by AI interpreter let g:litrepl_sh_auxdir=D --sh-auxdir=D The auxiliary files directory used by a shell interpreter let g:litrepl_workdir=D --workdir=D The auxiliary files directory used by AI interpreter let g:litrepl_debug=0/1 --debug=0/1 Print debug messages to the stderr let g:litrepl_timeout=FLOAT --timeout=FLOAT Timeout to wait for the new executions, in seconds, defaults to inf T Type of the document: tex or markdown (the default). B Interpreter command to use, - or auto (the default). - value disabled this type of interpreters; auto asks litrep to guess the best available interpreter. D Filesystem directory FLOAT Should be formatted as 1 or 1.1 or inf . Note: command line argument also accepts a pair of timeouts.","title":"Command Line Arguments and Vim Variables"},{"location":"reference/#command-line-arguments-summary","text":"usage: litrepl [-h] [-v] [--filetype STR] [--python-markers STR[,STR]] [--ai-markers STR[,STR]] [--sh-markers STR[,STR]] [--python-interpreter EXE] [--ai-interpreter EXE] [--sh-interpreter EXE] [--python-auxdir DIR] [--ai-auxdir DIR] [--sh-auxdir DIR] [--timeout F[,F]] [--propagate-sigint] [-d INT] [--verbose] [-C DIR] [--pending-exitcode INT] [--irreproducible-exitcode INT] [--exception-exitcode INT] [--foreground] [--map-cursor LINE:COL:FILE] [--result-textwidth NUM] {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} ... positional arguments: {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} Commands to execute start Start a background interpreter. The CLASS of an interpreter should be specified. --<CLASS>-interpreter, --<CLASS>-auxdir etc. are applied. stop Stop the background interpreters. restart Restart the background interpreters. status Print background interpreter's status. parse Parse the input file without futher processing (diagnostics). parse-print Parse and print the input file back (diagnostics). eval-sections Parse stdin, evaluate the specified sections (by default - all available sections), print the resulting file to stdout. eval-code Evaluate the code snippet. repl Connect to the background terminal using GNU socat. interrupt Send SIGINT to the background interpreter. print-regexp Print regexp matching start of code sections for the given file type. print-grammar Print the resulting grammar for the given filetype. print-auxdir Print the auxdir for the given interpreter type. options: -h, --help show this help message and exit -v, --version Print version. --filetype STR Specify the type of input formatting (markdown|[la]tex|auto). --python-markers STR[,STR] Specify section markers recognized as `python` sections. Defaults to the value of LITREPL_PYTHON_MARERS if set, otherwize \"python\". --ai-markers STR[,STR] Specify section markers recognized as `ai` sections. Defaults to the value of LITREPL_AI_MARERS if set, otherwize \"codeai,ai\". --sh-markers STR[,STR] Specify section markers recognized as `shell` sections. Defaults to the value of LITREPL_SH_MARERS if set, otherwize \"shell\". --python-interpreter EXE Python interpreter command line, or `auto`. Defaults to the LITREPL_PYTHON_INTERPRETER environment variable if set, otherwise \"auto\". Litrepl determines \"python\" or \"ipython\" type according to the value. --ai-interpreter EXE `aicli` interpreter command line or `auto`. Defaults to the LITREPL_AI_INTERPRETER environment variable if set, otherwise \"auto\". --sh-interpreter EXE Shell interpreter command line or `auto`. Defaults to the LITREPL_SH_INTERPRETER environment variable if set, otherwise \"auto\". --python-auxdir DIR This directory stores Python interpreter pipes. It defaults to LITREPL_PYTHON_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --ai-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_AI_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --sh-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_SH_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --timeout F[,F] Timeouts for initial evaluation and for pending checks, in seconds. If the latter is omitted, it is considered to be equal to the former one. --propagate-sigint If set, litrepl will catch and resend SIGINT signals to the running interpreter. Otherwise it will just terminate itself leaving the interpreter as-is. -d INT, --debug INT Enable (a lot of) debug messages. --verbose Be more verbose (used in status). -C DIR, --workdir DIR Set the working directory before execution. By default, it uses LITREPL_WORKDIR if set, otherwise remains the current directory. This affects the directory of a new interpreter and the --<interpreter>-auxdir option. --pending-exitcode INT Return this error code if whenever a section hits timeout. --irreproducible-exitcode INT Return this error code if a section outputs a different result than the one that is already present in the document. --exception-exitcode INT Return this error code at exception, if any. Note: this option might not be defined for some interpreters. It takes affect only for newly- started interpreters. --foreground Start a separate session and stop it when the evaluation is done. All --*-auxdir settings are ignored in this mode. --map-cursor LINE:COL:FILE Calculate the new position of a cursor at LINE:COL and write it to FILE. --result-textwidth NUM Wrap result lines longer than NUM symbols.","title":"Command Line Arguments Summary"},{"location":"related/","text":"Related Tools and Projects Edititng: https://github.com/lervag/vimtex (LaTeX editing, LaTeX preview) https://github.com/shime/vim-livedown (Markdown preview) https://github.com/preservim/vim-markdown (Markdown editing) Code execution: Vim-medieval https://github.com/gpanders/vim-medieval Evaluates Markdown code sections Pyluatex https://www.ctan.org/pkg/pyluatex Magma-nvim https://github.com/dccsillag/magma-nvim Codi https://github.com/metakirby5/codi.vim Pythontex https://github.com/gpoore/pythontex Evaluates Latex code sections Codebraid https://github.com/gpoore/codebraid Vim-ipython-cell https://github.com/hanschen/vim-ipython-cell Vim-ipython https://github.com/ivanov/vim-ipython Jupytext https://github.com/goerz/jupytext.vim Alternative? https://github.com/mwouts/jupytext Ipython-vimception https://github.com/ivanov/ipython-vimception Considerations for Third-Party Tools Vim-plug https://github.com/junegunn/vim-plug/issues/1010#issuecomment-1221614232 Pandoc https://github.com/jgm/pandoc/issues/8598 Jupytext https://github.com/mwouts/jupytext/issues/220#issuecomment-1418209581 Vim-LSC https://github.com/natebosch/vim-lsc/issues/469","title":"Related"},{"location":"related/#related","text":"","title":"Related"},{"location":"related/#tools-and-projects","text":"Edititng: https://github.com/lervag/vimtex (LaTeX editing, LaTeX preview) https://github.com/shime/vim-livedown (Markdown preview) https://github.com/preservim/vim-markdown (Markdown editing) Code execution: Vim-medieval https://github.com/gpanders/vim-medieval Evaluates Markdown code sections Pyluatex https://www.ctan.org/pkg/pyluatex Magma-nvim https://github.com/dccsillag/magma-nvim Codi https://github.com/metakirby5/codi.vim Pythontex https://github.com/gpoore/pythontex Evaluates Latex code sections Codebraid https://github.com/gpoore/codebraid Vim-ipython-cell https://github.com/hanschen/vim-ipython-cell Vim-ipython https://github.com/ivanov/vim-ipython Jupytext https://github.com/goerz/jupytext.vim Alternative? https://github.com/mwouts/jupytext Ipython-vimception https://github.com/ivanov/ipython-vimception","title":"Tools and Projects"},{"location":"related/#considerations-for-third-party-tools","text":"Vim-plug https://github.com/junegunn/vim-plug/issues/1010#issuecomment-1221614232 Pandoc https://github.com/jgm/pandoc/issues/8598 Jupytext https://github.com/mwouts/jupytext/issues/220#issuecomment-1418209581 Vim-LSC https://github.com/natebosch/vim-lsc/issues/469","title":"Considerations for Third-Party Tools"},{"location":"examples/basic/","text":"print('Hello Markdown!')","title":"Basic"},{"location":"examples/example/","text":"Executable sections are marked with the \"python\" tag. Putting the cursor on one of the typing the :LitEval1 command executes its code in a background Python interpreter. W='Hello, World!' print(W) Verbatim sections next to the executable section are result sections. Litrepl pastes the result here during the evaluation. The original content of this section is replaced. Hello, World! Markdown comment-looking tags result / noresult also mark executable and result sections. They allow to generate the Markdown document markup. Hello, LitREPL","title":"Example"},{"location":"static/description/","text":"command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style.","title":"Description"},{"location":"usage/application-scenarios/","text":"Application Scenarios Command Line, Foreground Evaluation When performing batch processing of documents, it might be necessary to initiate a new interpreter session solely for the evaluation's duration rather than re-using the currently running session. The --foreground option can be used to activate this mode. $ cat document.md.in | litrepl --foreground eval-sections > document.md Command Line, Detecting Python Exceptions Another frequently requested feature is the ability to report unhandled exceptions. Litrepl can be configured to return a non-zero exit code in such scenarios. $ cat document.md ``` python raise Exception(\"D'oh!\") ``` $ cat document.md | litrepl --foreground --exception-exit=200 eval-sections $ echo $? 200 In this example, the --foreground option instructs Litrepl to start a new interpreter session, stopping it upon completion. The --exception-exit=200 option specifies the exit code to be returned in the event of unhandled exceptions. GNU Make, Evaluating Code Sections in Project Documentation A typical Makefile recipe for updating documentation is structured as follows: SRC = $(shell find -name '*\\.py') .stamp_readme: $(SRC) Makefile cp README.md _README.md.in cat _README.md.in | \\ litrepl --foreground --exception-exit=100 \\ --python-interpreter=ipython \\ --sh-interpreter=- \\ eval-sections >README.md touch $@ .PHONY: readme readme: .stamp_readme Here, $(SRC) is expected to include the filenames of dependencies. With this recipe, we can run make readme to evaluate the python sections. By passing - wealso tell Litrepl to ignore shell sections. Vim, Setting Up Keybindings The litrepl.vim plugin does not define any keybindings, but users could do it by themselves, for example: nnoremap <F5> :LEval<CR> nnoremap <F6> :LEvalAsync<CR> Vim, Inserting New Sections The litrepl.vim plugin doesn't include tools for creating section formatting, however they can be added easily if required. Below, we demonstrate how to define the :C command inserting new python sections. command! -buffer -nargs=0 C normal 0i``` python<CR>```<CR><CR>``` result<CR>```<Esc>4k Vim, Running the Initial Section After Interpreter Restart Below we demonstrate how to define the :LR command for running first section after the restart. command! -nargs=0 LR LRestart | LEval 0 Vim, Evaluating Selected Text Litrepl vim plugin defines LitReplEvalSelection function which runs the selection as a virtual code section. The section type is passed as the function argument. For example, calling LitReplEvalSelection('ai') will execute the selection as if it is an ai code section. The execution result is pasted right after the selection as a plain text. LitReplEvalSelection('python') would pipe the selection through the current Python interpreter. To use the feature, define a suitable key binding ( Ctrl+K in this example), vnoremap <C-k> :call LitReplEvalSelection('ai')<CR> Now write a question to the AI in any document, select it and hit Ctrl+K. Hi model. What is the capital of New Zealand? Upon the keypress, Litrepl pipes the selection through the AI interpreter - the aicli at the time of this writing - and paste the response right after the last line of the original selection. Hi model. What is the capital of New Zealand? The capital of New Zealand is Wellington. Internally, the plugin just uses eval-code Litrepl command. Vim, Calling for AI on a visual selection The repository includes litrepl_extras.vim , which defines extra tools for interacting with AI. These tools are based on the single low-level LitReplAIQuery() function. The function enables the creation of an AI chat query possibly incorporating the current file and any selected text. The AI model's response then returned alongside with the Litrepl error code. Based on this function, the following two middle-level functions are defined: - LitReplTaskNew(scope, prompt) - LitReplTaskContinue(scope, prompt) Both functions take the prompt, produce the AI model response and decide where to insert it. However, the key difference is that the first function determines the target location based on user input (like cursor position or selection), while the second function re-applies the previously used position, allowing users to make changes easilly. Finally, a number of high-level commands have been established. Each of these commands receives an input string that directs the model on what action to take. The user input can contain /S or /F tokens, which are replaced with the values of the visual selection and the current file, respectively. Command Description Incorporates Updates LAI Passes the prompt as-is Input, Selection Cursor, Selection LAICont Passes the prompt as-is Input, Selection Last LAIStyle Asks to improve language style Input, Selection Selection LAICode Asks to modify a code snippet Input, Selection Cursor, Selection LAITell Asks to describe a code snippet Input, Selection Terminal* LAIFile Asks to change a whole file Input, Selection, File File LAITell shows the response in the AI terminal instead of inserting it into the document. As with the selection evaluation mode, the aicli interpreter stays active in the background, maintaining the log of the conversation. Direct interaction with the interpreter functions as expected. The LTerm ai command opens the Vim terminal as usual, enabling communication with a model through aicli text commands.","title":"Application Scenarios"},{"location":"usage/application-scenarios/#application-scenarios","text":"","title":"Application Scenarios"},{"location":"usage/application-scenarios/#command-line-foreground-evaluation","text":"When performing batch processing of documents, it might be necessary to initiate a new interpreter session solely for the evaluation's duration rather than re-using the currently running session. The --foreground option can be used to activate this mode. $ cat document.md.in | litrepl --foreground eval-sections > document.md","title":"Command Line, Foreground Evaluation"},{"location":"usage/application-scenarios/#command-line-detecting-python-exceptions","text":"Another frequently requested feature is the ability to report unhandled exceptions. Litrepl can be configured to return a non-zero exit code in such scenarios. $ cat document.md ``` python raise Exception(\"D'oh!\") ``` $ cat document.md | litrepl --foreground --exception-exit=200 eval-sections $ echo $? 200 In this example, the --foreground option instructs Litrepl to start a new interpreter session, stopping it upon completion. The --exception-exit=200 option specifies the exit code to be returned in the event of unhandled exceptions.","title":"Command Line, Detecting Python Exceptions"},{"location":"usage/application-scenarios/#gnu-make-evaluating-code-sections-in-project-documentation","text":"A typical Makefile recipe for updating documentation is structured as follows: SRC = $(shell find -name '*\\.py') .stamp_readme: $(SRC) Makefile cp README.md _README.md.in cat _README.md.in | \\ litrepl --foreground --exception-exit=100 \\ --python-interpreter=ipython \\ --sh-interpreter=- \\ eval-sections >README.md touch $@ .PHONY: readme readme: .stamp_readme Here, $(SRC) is expected to include the filenames of dependencies. With this recipe, we can run make readme to evaluate the python sections. By passing - wealso tell Litrepl to ignore shell sections.","title":"GNU Make, Evaluating Code Sections in Project Documentation"},{"location":"usage/application-scenarios/#vim-setting-up-keybindings","text":"The litrepl.vim plugin does not define any keybindings, but users could do it by themselves, for example: nnoremap <F5> :LEval<CR> nnoremap <F6> :LEvalAsync<CR>","title":"Vim, Setting Up Keybindings"},{"location":"usage/application-scenarios/#vim-inserting-new-sections","text":"The litrepl.vim plugin doesn't include tools for creating section formatting, however they can be added easily if required. Below, we demonstrate how to define the :C command inserting new python sections. command! -buffer -nargs=0 C normal 0i``` python<CR>```<CR><CR>``` result<CR>```<Esc>4k","title":"Vim, Inserting New Sections"},{"location":"usage/application-scenarios/#vim-running-the-initial-section-after-interpreter-restart","text":"Below we demonstrate how to define the :LR command for running first section after the restart. command! -nargs=0 LR LRestart | LEval 0","title":"Vim, Running the Initial Section After Interpreter Restart"},{"location":"usage/application-scenarios/#vim-evaluating-selected-text","text":"Litrepl vim plugin defines LitReplEvalSelection function which runs the selection as a virtual code section. The section type is passed as the function argument. For example, calling LitReplEvalSelection('ai') will execute the selection as if it is an ai code section. The execution result is pasted right after the selection as a plain text. LitReplEvalSelection('python') would pipe the selection through the current Python interpreter. To use the feature, define a suitable key binding ( Ctrl+K in this example), vnoremap <C-k> :call LitReplEvalSelection('ai')<CR> Now write a question to the AI in any document, select it and hit Ctrl+K. Hi model. What is the capital of New Zealand? Upon the keypress, Litrepl pipes the selection through the AI interpreter - the aicli at the time of this writing - and paste the response right after the last line of the original selection. Hi model. What is the capital of New Zealand? The capital of New Zealand is Wellington. Internally, the plugin just uses eval-code Litrepl command.","title":"Vim, Evaluating Selected Text"},{"location":"usage/application-scenarios/#vim-calling-for-ai-on-a-visual-selection","text":"The repository includes litrepl_extras.vim , which defines extra tools for interacting with AI. These tools are based on the single low-level LitReplAIQuery() function. The function enables the creation of an AI chat query possibly incorporating the current file and any selected text. The AI model's response then returned alongside with the Litrepl error code. Based on this function, the following two middle-level functions are defined: - LitReplTaskNew(scope, prompt) - LitReplTaskContinue(scope, prompt) Both functions take the prompt, produce the AI model response and decide where to insert it. However, the key difference is that the first function determines the target location based on user input (like cursor position or selection), while the second function re-applies the previously used position, allowing users to make changes easilly. Finally, a number of high-level commands have been established. Each of these commands receives an input string that directs the model on what action to take. The user input can contain /S or /F tokens, which are replaced with the values of the visual selection and the current file, respectively. Command Description Incorporates Updates LAI Passes the prompt as-is Input, Selection Cursor, Selection LAICont Passes the prompt as-is Input, Selection Last LAIStyle Asks to improve language style Input, Selection Selection LAICode Asks to modify a code snippet Input, Selection Cursor, Selection LAITell Asks to describe a code snippet Input, Selection Terminal* LAIFile Asks to change a whole file Input, Selection, File File LAITell shows the response in the AI terminal instead of inserting it into the document. As with the selection evaluation mode, the aicli interpreter stays active in the background, maintaining the log of the conversation. Direct interaction with the interpreter functions as expected. The LTerm ai command opens the Vim terminal as usual, enabling communication with a model through aicli text commands.","title":"Vim, Calling for AI on a visual selection"},{"location":"usage/formatting/","text":"Formatting Markdown Basic syntax Executable sections are verbatim sections marked with a number of tags, including \"python\" and \"code\". ``` python W='Hello, World!' print(W) ``` Verbatim result sections might be marked as \"result\" or \"lresult\". ``` result Hello, World! ``` Markdown comments tagged with result / noresult (see an example below) also mark result sections. This syntax allows emitting parts of Markdown document. <!-- result --> Hello, World! <!-- noresult --> Converting to Jupyter Notebook Pandoc could be used to conver LitREPL-frinedly markdown documents to the Jupyter Notebook format. In order to make it recognize the code and result fields, addtional formatting is required. Currently we aware of two options: Using fenced Markdown syntax extension Mark Jupyter sections with fenced-div markup as described in the Pandoc manual . Consider the following file.md : :::::: {.cell .code execution_count=1} ```python print(\"Hello Jupyter!\") ``` ::: {.output .stream .stdout} ``` result Hello Jupyter! ``` ::: :::::: The above format is recognized by both Litrepl and Pandoc , so to convert it to the Jupyter Notebook format one may run: $ pandoc file.md -o file.ipynb Unfortunately, other renderers may interpret fenced divs incorrectly. Using Native divs syntax extension Alternatively, native divs syntax extension could be used. Consider the following file.md file: <div class=\"cell code\"> ```python print(\"Hello Jupyter!\") ``` <div class=\"output stream stdout\"> ```result Hello Jupyter! ``` </div> </div> Both Litrepl and Pandoc will recognize this format, plus most third-party renderers will ignore div tags. The downside of this approach is the fact that pandoc now needs native divs extension to convert the document: $ pandoc -f markdown+native_divs file.md -o test.ipynb Latex Basic syntax LitREPL treats \\begin{python}\\end{python} environment as code sections and \\begin{result}\\end{result} environment as result sections. The names are currently hardcoded into the simplified LitREPL parser. Wrapping it in other tags is not allowed. LaTeX does not know anything about these environments by default, so we need to introduce these environments in the preamble: \\documentclass{article} \\usepackage[utf8]{inputenc} \\begin{document} \\newenvironment{python}{\\begin{texttt}}{\\end{texttt}} \\newenvironment{result}{\\begin{texttt}}{\\end{texttt}} \\newcommand{\\linline}[2]{#2} \\begin{document} ... \\end{document} Executable sections is the document are enclosed with the python tags, results - wtih result tags: \\begin{python} W='Hello, World!' print(W) \\end{python} \\begin{result} Hello, World! \\end{result} LitREPL recognizes result / noresult LaTeX comments as result section markers. This way we can use Python to emit LaTeX markup as output. %result Hello, World! %noresult Additionally, LitREPL recognises linline 2-argument tags. The first arguement is treated as a Python printable expression. The second arguemnt is an immediate result section where the value of expression will be placed. \\linline{W}{Hello, World!} In-PDF code highliting with Minted The following Latex instructions can be used to properly highlight the code and result sections. Note, that pygmentize system tool needs to be installed in the system. \\usepackage{minted} \\renewcommand{\\MintedPygmentize}{pygmentize} % LitREPL-compatible environment for Python code snippets \\newenvironment{python} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{python}} {\\end{minted}} \\BeforeBeginEnvironment{python}{\\begin{mdframed}[nobreak=false,everyline=true]} \\AfterEndEnvironment{python}{\\end{mdframed}} % LitREPL-compatible ai secitons \\newenvironment{ai} {\\vsp\\textbf{User:}\\vsp} {} \\newenvironment{airesult} {\\vsp\\textbf{AI:}\\vsp} {} % LitREPL-compatible environment for code results \\newenvironment{result} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{text}} {\\end{minted}} \\BeforeBeginEnvironment{result}{\\begin{mdframed}[nobreak=true,frametitle=\\tiny{Result}]} \\AfterEndEnvironment{result}{\\end{mdframed}} % LitREPL-compatible command for inline code results \\newcommand{\\linline}[2]{#2} \\newcommand{\\st}[1]{\\sout{#1}} \\renewcommand{\\t}[1]{\\texttt{#1}} Hint: Use \\usepackage[outputdir=_build]{minted} if you specify a separate build directory (here - _build ). This workarounds a well-known Minted problem. In-editor code highlighting with Vimtex The following .vimrc Vimtex configuration enables highlighting of Python code sections in LaTeX documents. We typically need to call these functions from the BufEnter event handler. \" .localvimrc call vimtex#syntax#nested#include('python') call vimtex#syntax#core#new_region_env('texLitreplZone', 'l[a-zA-Z0-9]*code', \\ {'contains': '@vimtex_nested_python'})","title":"Formatting"},{"location":"usage/formatting/#formatting","text":"","title":"Formatting"},{"location":"usage/formatting/#markdown","text":"","title":"Markdown"},{"location":"usage/formatting/#basic-syntax","text":"Executable sections are verbatim sections marked with a number of tags, including \"python\" and \"code\". ``` python W='Hello, World!' print(W) ``` Verbatim result sections might be marked as \"result\" or \"lresult\". ``` result Hello, World! ``` Markdown comments tagged with result / noresult (see an example below) also mark result sections. This syntax allows emitting parts of Markdown document. <!-- result --> Hello, World! <!-- noresult -->","title":"Basic syntax"},{"location":"usage/formatting/#converting-to-jupyter-notebook","text":"Pandoc could be used to conver LitREPL-frinedly markdown documents to the Jupyter Notebook format. In order to make it recognize the code and result fields, addtional formatting is required. Currently we aware of two options:","title":"Converting to Jupyter Notebook"},{"location":"usage/formatting/#using-fenced-markdown-syntax-extension","text":"Mark Jupyter sections with fenced-div markup as described in the Pandoc manual . Consider the following file.md : :::::: {.cell .code execution_count=1} ```python print(\"Hello Jupyter!\") ``` ::: {.output .stream .stdout} ``` result Hello Jupyter! ``` ::: :::::: The above format is recognized by both Litrepl and Pandoc , so to convert it to the Jupyter Notebook format one may run: $ pandoc file.md -o file.ipynb Unfortunately, other renderers may interpret fenced divs incorrectly.","title":"Using fenced Markdown syntax extension"},{"location":"usage/formatting/#using-native-divs-syntax-extension","text":"Alternatively, native divs syntax extension could be used. Consider the following file.md file: <div class=\"cell code\"> ```python print(\"Hello Jupyter!\") ``` <div class=\"output stream stdout\"> ```result Hello Jupyter! ``` </div> </div> Both Litrepl and Pandoc will recognize this format, plus most third-party renderers will ignore div tags. The downside of this approach is the fact that pandoc now needs native divs extension to convert the document: $ pandoc -f markdown+native_divs file.md -o test.ipynb","title":"Using Native divs syntax extension"},{"location":"usage/formatting/#latex","text":"","title":"Latex"},{"location":"usage/formatting/#basic-syntax_1","text":"LitREPL treats \\begin{python}\\end{python} environment as code sections and \\begin{result}\\end{result} environment as result sections. The names are currently hardcoded into the simplified LitREPL parser. Wrapping it in other tags is not allowed. LaTeX does not know anything about these environments by default, so we need to introduce these environments in the preamble: \\documentclass{article} \\usepackage[utf8]{inputenc} \\begin{document} \\newenvironment{python}{\\begin{texttt}}{\\end{texttt}} \\newenvironment{result}{\\begin{texttt}}{\\end{texttt}} \\newcommand{\\linline}[2]{#2} \\begin{document} ... \\end{document} Executable sections is the document are enclosed with the python tags, results - wtih result tags: \\begin{python} W='Hello, World!' print(W) \\end{python} \\begin{result} Hello, World! \\end{result} LitREPL recognizes result / noresult LaTeX comments as result section markers. This way we can use Python to emit LaTeX markup as output. %result Hello, World! %noresult Additionally, LitREPL recognises linline 2-argument tags. The first arguement is treated as a Python printable expression. The second arguemnt is an immediate result section where the value of expression will be placed. \\linline{W}{Hello, World!}","title":"Basic syntax"},{"location":"usage/formatting/#in-pdf-code-highliting-with-minted","text":"The following Latex instructions can be used to properly highlight the code and result sections. Note, that pygmentize system tool needs to be installed in the system. \\usepackage{minted} \\renewcommand{\\MintedPygmentize}{pygmentize} % LitREPL-compatible environment for Python code snippets \\newenvironment{python} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{python}} {\\end{minted}} \\BeforeBeginEnvironment{python}{\\begin{mdframed}[nobreak=false,everyline=true]} \\AfterEndEnvironment{python}{\\end{mdframed}} % LitREPL-compatible ai secitons \\newenvironment{ai} {\\vsp\\textbf{User:}\\vsp} {} \\newenvironment{airesult} {\\vsp\\textbf{AI:}\\vsp} {} % LitREPL-compatible environment for code results \\newenvironment{result} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{text}} {\\end{minted}} \\BeforeBeginEnvironment{result}{\\begin{mdframed}[nobreak=true,frametitle=\\tiny{Result}]} \\AfterEndEnvironment{result}{\\end{mdframed}} % LitREPL-compatible command for inline code results \\newcommand{\\linline}[2]{#2} \\newcommand{\\st}[1]{\\sout{#1}} \\renewcommand{\\t}[1]{\\texttt{#1}} Hint: Use \\usepackage[outputdir=_build]{minted} if you specify a separate build directory (here - _build ). This workarounds a well-known Minted problem.","title":"In-PDF code highliting with Minted"},{"location":"usage/formatting/#in-editor-code-highlighting-with-vimtex","text":"The following .vimrc Vimtex configuration enables highlighting of Python code sections in LaTeX documents. We typically need to call these functions from the BufEnter event handler. \" .localvimrc call vimtex#syntax#nested#include('python') call vimtex#syntax#core#new_region_env('texLitreplZone', 'l[a-zA-Z0-9]*code', \\ {'contains': '@vimtex_nested_python'})","title":"In-editor code highlighting with Vimtex"},{"location":"usage/general-concepts/","text":"General concepts The Litrepl tool identifies code and result sections within a text document. It processes the code by sending it to the appropriate interpreters and populates the result sections with their responses. The interpreters remain active in the background, ready to handle new inputs. Litrepl supports subsets of Markdown and LaTeX formatting in order to recognize the sections. Some aspects of the recognized grammars, such as section labels, could be configured. Basic Execution Litrepl searches for verbatim code sections followed by zero or more result sections. In Markdown documents, the Python code is any triple-quoted section with a pre-configured label such as python . The result is any triple-quoted result section. In LaTeX documents, sections are marked with \\begin{...}\\end{...} environments correspondingly. The primary command for evaluating formatted documents is litrepl eval-sections . Consider a markdown document file.md . ``` python print('Hello Markdown!') ``` ``` result ``` We pass it to Litrepl using: $ cat file.md | litrepl eval-sections > result.md The result.md will have all sections filled in correctly. ``` python print('Hello Markdown!') ``` ``` result Hello Markdown! ``` For additional details on Markdown formatting, refer to Formatting Markdown documents In a similar LaTeX document, the code and result sections would be: \\begin{python} print('Hello LaTeX!') \\end{python} \\begin{result} Hello LaTeX! \\end{result} LaTeX documents require a preamble introducing python/result environments to the TeX processor. For more information, see Formatting LaTeX documents . By default, Litrepl tried to guess the format of the input document. Use the --filetype=(latex|markdown) option to set the format explicitly: $ cat doc.md | litrepl --filetype=markdown eval-sections $ cat doc.tex | litrepl --filetype=latex eval-sections The main Vim command for code section evaluation is :LEval . By default, it executes the section at the cursor. To execute all sections in a document, use :LEval all . Selecting Sections for Execution By default, litrepl eval-sections evaluates all sections in a document. To evaluate only specific sections, the range argument should be specified. The overall syntax is litrepl eval-sections [RANGE] , where RANGE can be: N : Represents a specific code section to evaluate, with the following possible formats: A number starting from 0 . $ symbol, indicating the last section. L:C , referring to the line and column position. Litrepl calculates the section number based on this position. N..N : Represents a range of sections, determined using the rules mentioned above. Some examples: $ litrepl eval-sections '0' # First section in a document $ litrepl eval-sections '3..$' # Sections from fourth section (zero based) to the last one $ litrepl eval-sections '34:1..$' # Sections starting from line 34 column 1 The Vim command :LEval accepts similar syntax and also recognizes specific keywords all , above , and below . These keywords allow you to evaluate all sections, only those above the cursor, or just the ones below the cursor, respectively. Managing Interpreter Sessions Each interpreter session uses an auxiliary directory where Litrepl stores filesystem pipes and other runtime data. By default, the auxiliary directory path is derived from the working directory name (for Vim, this defaults to the directory of the current file). This behavior can be configured by: * Setting the working directory with LITREPL_WORKDIR environment variable or --workdir=DIR command-line argument (this may also affect the current directory of the interpreters), or * Explicitly setting the auxiliary directory with LITREPL_<CLASS>_AUXDIR environment variable or --<class>-auxdir=DIR command-line argument, where <class> stands for either python , ai or sh . The commands litrepl start CLASS , litrepl stop [CLASS] , and litrepl restart [CLASS] are used to manage interpreter sessions. They accept the interpreter type to operate on or (for some commands) the keyword all to apply the command to all interpreters. Add the --<class>-interpteter=CMDLINE to adjust the command line to run, but be careful - Litrepl adds more arguments to configure prompts and verbosity to some interpreters, notably to the pythons. $ litrepl --python-interpreter=ipython start python $ litrepl --sh-interpreter=/opt/bin/mybash start sh $ litrepl restart all $ litrepl stop The equivalent Vim commands are :LStart CLASS , :LStop [CLASS] , and :LRestart [CLASS] . For the corresponding Vim configuration variables, see the reference section below. The litrepl status [CLASS] command queries the information about the currently running interpreters. The command reveals the process PID and the command-line arguments. For stopped interpreters, the last exit codes are also listed. Specifying CLASS prints the status for this class of interpreters only. $ litrepl status # Format: # CLASS PID EXITCODE CMD python 3900919 - python3 -m IPython --config=/tmp/litrepl_1000_a2732d/python/litrepl_ipython_config.py --colors=NoColor -i ai 3904696 - aicli --readline-prompt= The corresponding Vim command is :LStatus . No CLASS argument is currently supported. Asynchronous Processing Litrepl can generate an output document before the interpreter has finished processing. If the evaluation takes longer than a timeout, Litrepl leaves a marker, enabling it to continue from where it was stopped during future runs. The --timeout=SEC[,SEC] option allows you to set timeouts. The first number specifies the initial execution timeout in seconds, while the optional second number sets the timeout for subsequent attempts. By default, both timeouts are set to infinity. For instance, executing litrepl --timeout=3.5 eval-sections on the corresponding program yields: ``` python from tqdm import tqdm from time import sleep for i in tqdm(range(10)): sleep(1) ``` ``` result 30%|\u2588\u2588\u2588 | 3/10 [00:03<00:07, 1.00s/it] [BG:/tmp/nix-shell.vijcH0/litrepl_1000_a2732d/python/litrepl_eval_5503542553591491252.txt] ``` Upon re-executing the document, Litrepl resumes processing from the marker. Once evaluation concludes, it removes the marker from the output section. The command litrepl interrupt sends an interrupt signal to the interpreter, prompting it to return control sooner (with an exception). The equivalent Vim commands are :LEvalAsync (defaulting to a 0.5-second timeout) and :LInterrupt . The Vim plugin also provides the :LEvalMon command, which facilitates continuous code evaluation with no delay. Interrupting this with Ctrl+C will make Litrepl return control to the editor, leaving the evaluation ongoing in the background. Attaching Interpreter Sessions The command litrepl repl [CLASS] where CLASS specifies interpreter class: python (the default) ai or sh , attaches to interpreter sessions. For this command to work, socat tool needs to be installed on your system. Litrepl blocks the pipes for the time of interaction so no evaluation is possible while the repl session is active. For Python and Shell interpreters, the command prompt is disabled which is a current technical limitation. Use Ctrl+D to safely detach the session. For example: $ litrepl repl python Opening the interpreter terminal (NO PROMPTS, USE `Ctrl+D` TO DETACH) W = 'Hello from repl' ^D $ Use litrepl eval-code [CLASS] to direct code straight to the interpreter, bypassing any section formatting steps. In contrast to the repl command, eval-code mode features prompt detection, allowing the tool to display the interpreter's response and detach while keeping the session open. For example, after manually defining the W variable in the example above, it can be queried as in a typical IPython session. $ echo 'W' | litrepl eval-code 'Hello from repl' The eval-code command can be utilized for batch processing and managing sessions, in a manner similar to how the expect tool is used. The equivalent Vim commands are :LRepl [CLASS] or :LTerm [CLASS] . Both commands open Vim terminal window. Experimental AI Features Litrepl experimentally supports Aicli terminal allowing users to query external language models. In order to try it, install the interpreter and use ai as the name for code sections. For low-speed models it might be convenient to use :LEvalMon command to monitor the text generation in real time. ``` ai /model gpt4all:\"./_models/Meta-Llama-3-8B-Instruct.Q4_0.gguf\" Hi chat! What is your name? ``` ``` result I'm LLaMA, a large language model trained by Meta AI. I'm here to help answer any questions you might have and provide information on a wide range of topics. How can I assist you today? ``` All Aicli / -commands like the /model command above are passed as-is to the interpreter. The /ask command is added automatically at the of each section, so make sure that ai secions have self-contained questions. As a pre-processing step, Litrepl can paste text from other sections of the document in place of special reference markers. The markers have the following format: >>RX<< , where X is a number - references a section number X (starting from zero). ^^RX^^ , where X is a number - references the section X times above the current one. vvRXvv , where X is a number - references the section X times below the current one. ``` ai AI, what do you think the following text means? ^^R1^^ ``` ``` result Another interesting piece of text! This is an example of a chatbot introduction or \"hello message.\" It appears to be written in a friendly, approachable tone, with the goal of establishing a connection with users. ```","title":"General concepts"},{"location":"usage/general-concepts/#general-concepts","text":"The Litrepl tool identifies code and result sections within a text document. It processes the code by sending it to the appropriate interpreters and populates the result sections with their responses. The interpreters remain active in the background, ready to handle new inputs. Litrepl supports subsets of Markdown and LaTeX formatting in order to recognize the sections. Some aspects of the recognized grammars, such as section labels, could be configured.","title":"General concepts"},{"location":"usage/general-concepts/#basic-execution","text":"Litrepl searches for verbatim code sections followed by zero or more result sections. In Markdown documents, the Python code is any triple-quoted section with a pre-configured label such as python . The result is any triple-quoted result section. In LaTeX documents, sections are marked with \\begin{...}\\end{...} environments correspondingly. The primary command for evaluating formatted documents is litrepl eval-sections . Consider a markdown document file.md . ``` python print('Hello Markdown!') ``` ``` result ``` We pass it to Litrepl using: $ cat file.md | litrepl eval-sections > result.md The result.md will have all sections filled in correctly. ``` python print('Hello Markdown!') ``` ``` result Hello Markdown! ``` For additional details on Markdown formatting, refer to Formatting Markdown documents In a similar LaTeX document, the code and result sections would be: \\begin{python} print('Hello LaTeX!') \\end{python} \\begin{result} Hello LaTeX! \\end{result} LaTeX documents require a preamble introducing python/result environments to the TeX processor. For more information, see Formatting LaTeX documents . By default, Litrepl tried to guess the format of the input document. Use the --filetype=(latex|markdown) option to set the format explicitly: $ cat doc.md | litrepl --filetype=markdown eval-sections $ cat doc.tex | litrepl --filetype=latex eval-sections The main Vim command for code section evaluation is :LEval . By default, it executes the section at the cursor. To execute all sections in a document, use :LEval all .","title":"Basic Execution"},{"location":"usage/general-concepts/#selecting-sections-for-execution","text":"By default, litrepl eval-sections evaluates all sections in a document. To evaluate only specific sections, the range argument should be specified. The overall syntax is litrepl eval-sections [RANGE] , where RANGE can be: N : Represents a specific code section to evaluate, with the following possible formats: A number starting from 0 . $ symbol, indicating the last section. L:C , referring to the line and column position. Litrepl calculates the section number based on this position. N..N : Represents a range of sections, determined using the rules mentioned above. Some examples: $ litrepl eval-sections '0' # First section in a document $ litrepl eval-sections '3..$' # Sections from fourth section (zero based) to the last one $ litrepl eval-sections '34:1..$' # Sections starting from line 34 column 1 The Vim command :LEval accepts similar syntax and also recognizes specific keywords all , above , and below . These keywords allow you to evaluate all sections, only those above the cursor, or just the ones below the cursor, respectively.","title":"Selecting Sections for Execution"},{"location":"usage/general-concepts/#managing-interpreter-sessions","text":"Each interpreter session uses an auxiliary directory where Litrepl stores filesystem pipes and other runtime data. By default, the auxiliary directory path is derived from the working directory name (for Vim, this defaults to the directory of the current file). This behavior can be configured by: * Setting the working directory with LITREPL_WORKDIR environment variable or --workdir=DIR command-line argument (this may also affect the current directory of the interpreters), or * Explicitly setting the auxiliary directory with LITREPL_<CLASS>_AUXDIR environment variable or --<class>-auxdir=DIR command-line argument, where <class> stands for either python , ai or sh . The commands litrepl start CLASS , litrepl stop [CLASS] , and litrepl restart [CLASS] are used to manage interpreter sessions. They accept the interpreter type to operate on or (for some commands) the keyword all to apply the command to all interpreters. Add the --<class>-interpteter=CMDLINE to adjust the command line to run, but be careful - Litrepl adds more arguments to configure prompts and verbosity to some interpreters, notably to the pythons. $ litrepl --python-interpreter=ipython start python $ litrepl --sh-interpreter=/opt/bin/mybash start sh $ litrepl restart all $ litrepl stop The equivalent Vim commands are :LStart CLASS , :LStop [CLASS] , and :LRestart [CLASS] . For the corresponding Vim configuration variables, see the reference section below. The litrepl status [CLASS] command queries the information about the currently running interpreters. The command reveals the process PID and the command-line arguments. For stopped interpreters, the last exit codes are also listed. Specifying CLASS prints the status for this class of interpreters only. $ litrepl status # Format: # CLASS PID EXITCODE CMD python 3900919 - python3 -m IPython --config=/tmp/litrepl_1000_a2732d/python/litrepl_ipython_config.py --colors=NoColor -i ai 3904696 - aicli --readline-prompt= The corresponding Vim command is :LStatus . No CLASS argument is currently supported.","title":"Managing Interpreter Sessions"},{"location":"usage/general-concepts/#asynchronous-processing","text":"Litrepl can generate an output document before the interpreter has finished processing. If the evaluation takes longer than a timeout, Litrepl leaves a marker, enabling it to continue from where it was stopped during future runs. The --timeout=SEC[,SEC] option allows you to set timeouts. The first number specifies the initial execution timeout in seconds, while the optional second number sets the timeout for subsequent attempts. By default, both timeouts are set to infinity. For instance, executing litrepl --timeout=3.5 eval-sections on the corresponding program yields: ``` python from tqdm import tqdm from time import sleep for i in tqdm(range(10)): sleep(1) ``` ``` result 30%|\u2588\u2588\u2588 | 3/10 [00:03<00:07, 1.00s/it] [BG:/tmp/nix-shell.vijcH0/litrepl_1000_a2732d/python/litrepl_eval_5503542553591491252.txt] ``` Upon re-executing the document, Litrepl resumes processing from the marker. Once evaluation concludes, it removes the marker from the output section. The command litrepl interrupt sends an interrupt signal to the interpreter, prompting it to return control sooner (with an exception). The equivalent Vim commands are :LEvalAsync (defaulting to a 0.5-second timeout) and :LInterrupt . The Vim plugin also provides the :LEvalMon command, which facilitates continuous code evaluation with no delay. Interrupting this with Ctrl+C will make Litrepl return control to the editor, leaving the evaluation ongoing in the background.","title":"Asynchronous Processing"},{"location":"usage/general-concepts/#attaching-interpreter-sessions","text":"The command litrepl repl [CLASS] where CLASS specifies interpreter class: python (the default) ai or sh , attaches to interpreter sessions. For this command to work, socat tool needs to be installed on your system. Litrepl blocks the pipes for the time of interaction so no evaluation is possible while the repl session is active. For Python and Shell interpreters, the command prompt is disabled which is a current technical limitation. Use Ctrl+D to safely detach the session. For example: $ litrepl repl python Opening the interpreter terminal (NO PROMPTS, USE `Ctrl+D` TO DETACH) W = 'Hello from repl' ^D $ Use litrepl eval-code [CLASS] to direct code straight to the interpreter, bypassing any section formatting steps. In contrast to the repl command, eval-code mode features prompt detection, allowing the tool to display the interpreter's response and detach while keeping the session open. For example, after manually defining the W variable in the example above, it can be queried as in a typical IPython session. $ echo 'W' | litrepl eval-code 'Hello from repl' The eval-code command can be utilized for batch processing and managing sessions, in a manner similar to how the expect tool is used. The equivalent Vim commands are :LRepl [CLASS] or :LTerm [CLASS] . Both commands open Vim terminal window.","title":"Attaching Interpreter Sessions"},{"location":"usage/general-concepts/#experimental-ai-features","text":"Litrepl experimentally supports Aicli terminal allowing users to query external language models. In order to try it, install the interpreter and use ai as the name for code sections. For low-speed models it might be convenient to use :LEvalMon command to monitor the text generation in real time. ``` ai /model gpt4all:\"./_models/Meta-Llama-3-8B-Instruct.Q4_0.gguf\" Hi chat! What is your name? ``` ``` result I'm LLaMA, a large language model trained by Meta AI. I'm here to help answer any questions you might have and provide information on a wide range of topics. How can I assist you today? ``` All Aicli / -commands like the /model command above are passed as-is to the interpreter. The /ask command is added automatically at the of each section, so make sure that ai secions have self-contained questions. As a pre-processing step, Litrepl can paste text from other sections of the document in place of special reference markers. The markers have the following format: >>RX<< , where X is a number - references a section number X (starting from zero). ^^RX^^ , where X is a number - references the section X times above the current one. vvRXvv , where X is a number - references the section X times below the current one. ``` ai AI, what do you think the following text means? ^^R1^^ ``` ``` result Another interesting piece of text! This is an example of a chatbot introduction or \"hello message.\" It appears to be written in a friendly, approachable tone, with the goal of establishing a connection with users. ```","title":"Experimental AI Features"}]}