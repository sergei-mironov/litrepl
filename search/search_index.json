{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Litrepl Litrepl is a command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style. The repository includes a Vim plugin to demonstrate editor integration.","title":"Home"},{"location":"#litrepl","text":"Litrepl is a command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style. The repository includes a Vim plugin to demonstrate editor integration.","title":"Litrepl"},{"location":"coverage/","text":"Coverage report !coverage report --format=markdown -m Name Stmts Miss Cover Missing python/litrepl/__init__.py 34 12 65% 24-29, 35-40 python/litrepl/base.py 590 84 86% 61, 92, 102, 150, 185, 214-218, 227-232, 242-244, 247-252, 255, 257, 266, 338, 340, 424, 436, 448, 459-464, 468, 472, 474, 476, 482-483, 486, 491, 493, 499, 512-513, 517, 523, 530, 532, 564, 566, 579, 594-596, 603, 615, 626, 653, 666, 710, 733-734, 745, 761, 778-787, 806-810, 814-817 python/litrepl/eval.py 340 26 92% 36, 39-40, 87-88, 100, 131, 157-158, 182-184, 199, 208, 309-310, 328, 337, 362, 375-378, 393-394, 418 python/litrepl/interpreters/__init__.py 0 0 100% python/litrepl/interpreters/aicli.py 49 19 61% 15-17, 36, 40-50, 59-65 python/litrepl/interpreters/ipython.py 29 1 97% 68 python/litrepl/interpreters/python.py 22 1 95% 39 python/litrepl/interpreters/shell.py 22 1 95% 26 python/litrepl/main.py 215 48 78% 23-25, 198-199, 250, 259, 276-281, 283-285, 296-307, 320, 323-324, 332-336, 345-353, 355-356, 362-363 python/litrepl/revision.py 1 1 0% 2 python/litrepl/semver.py 1 1 0% 2 python/litrepl/types.py 97 6 94% 145, 150, 156, 160, 164, 167 python/litrepl/utils.py 100 6 94% 37, 55, 129-132 TOTAL 1500 206 86%","title":"Coverage"},{"location":"coverage/#coverage-report","text":"!coverage report --format=markdown -m Name Stmts Miss Cover Missing python/litrepl/__init__.py 34 12 65% 24-29, 35-40 python/litrepl/base.py 590 84 86% 61, 92, 102, 150, 185, 214-218, 227-232, 242-244, 247-252, 255, 257, 266, 338, 340, 424, 436, 448, 459-464, 468, 472, 474, 476, 482-483, 486, 491, 493, 499, 512-513, 517, 523, 530, 532, 564, 566, 579, 594-596, 603, 615, 626, 653, 666, 710, 733-734, 745, 761, 778-787, 806-810, 814-817 python/litrepl/eval.py 340 26 92% 36, 39-40, 87-88, 100, 131, 157-158, 182-184, 199, 208, 309-310, 328, 337, 362, 375-378, 393-394, 418 python/litrepl/interpreters/__init__.py 0 0 100% python/litrepl/interpreters/aicli.py 49 19 61% 15-17, 36, 40-50, 59-65 python/litrepl/interpreters/ipython.py 29 1 97% 68 python/litrepl/interpreters/python.py 22 1 95% 39 python/litrepl/interpreters/shell.py 22 1 95% 26 python/litrepl/main.py 215 48 78% 23-25, 198-199, 250, 259, 276-281, 283-285, 296-307, 320, 323-324, 332-336, 345-353, 355-356, 362-363 python/litrepl/revision.py 1 1 0% 2 python/litrepl/semver.py 1 1 0% 2 python/litrepl/types.py 97 6 94% 145, 150, 156, 160, 164, 167 python/litrepl/utils.py 100 6 94% 37, 55, 129-132 TOTAL 1500 206 86%","title":"Coverage report"},{"location":"development/","text":"Development Litrepl uses Nix as its main development framework. The file flake.nix manages the source-level dependencies required by Nix, whereas default.nix specifies common build targets, including PyPI and Vim packages, demo Vim configurations, development shells, and more. Contributing The original author used his favorite Python coding style for this project, the following guidelines are applied: Use 2-space indentation for everything. Use CamelCase for class names and snake_case for function names Use explicit from <module> import <function> rather than import <module> for importing. Insert type annotations where possible, use old-style upper-case type names from the typing module. Avoid spaces where possible with the following exceptions: Import name lists Function argument declarations Building Nix Targets To build individual Nix expressions, execute the command nix build '.#NAME' , replacing NAME with the actual name of the Nix expression you want to build. If the build is successful, Nix places the results of the last build in a symbolic link located at ./result . For example, to build a version of Vim pre-configured for demo, run $ nix build '.#vim-demo' $ ./result/bin/vim-demo # Run the pre-configured demo instance of Vim The list of Nix build targets includes: litrepl-release - Litrepl script and Python lib litrepl-release-pypi - Litrepl script and Python lib vim-litrepl-release - Vim with locally built litrepl plugin vim-litrepl-release-pypi - Vim with litrepl plugin built from PYPI vim-test - A minimalistic Vim with a single litrepl plugin vim-demo - Vim configured to use litrepl suitable for recording screencasts. Uses the latest released version of Litrepl rather than the current revision. vim-plug - Vim configured to use litrepl via the Plug manager shell-dev - The development shell shell-screencast - The shell for recording demonstrations, includes vim-demo . See the local.collection attribute-set in the default.nix for the full list of defined targets. Note: The default development shell shell-dev installs many dependencies, the users are encouraged to define their own shells when needed. Development Environments and Setup The default development shell is defined in the ./default.nix as a Nix expression named shell which is the default name for development shells. Running $ nix develop will ask Nix to install the development dependencies and open the shell. Testing The runtests.sh script runs all tests by default, but accepts command-line arguments for running specific tests. Note, that Litrepl distinguishes the Python interpreter use to run the litrepl script ( -p argument) from the Python interpreters used to run the code sections ( -i argument). By default, ./runtest.sh runs the litrepl script with the python interpreter (whatever it is, leaving the OS to decide) and iterates over all visible Python interpreters for running code sections. [ LitREPL-DEV ] $ runtests.sh --help Usage: runtest.sh [-d] [-i I(,I)*] [-t T(,T)*] Arguments: -d Be very verbose -i I, --interpreters=I Run tests requiring interpreters matching the grep expression I Run -i '?' to list all available interpreters -t T, --tests=T Run tests whose names match the grep expression T Run -t '?' to list all available tests -p P, --python=P Use this Python interpreter to run Litrepl Run -p '?' to list available python interpreters -c FILE, --coverage=FILE Collect coverage results into the FILE. Defaults to `.coverage` if no tests or interpreters are selected, otherwize disabled. -c -, --coverage=- Disable coverage. Examples: runtests.sh -t '?' -i '?' runtests.sh -i ipython runtests.sh -t 'test_eval_code|test_status' -i python The project Makefile provides a couple of phony targets for testing: make test runs the testing with all default parameters (effectively checking all visible Python interpreters), while the make test-small makes a run with the default system Python and IPython interpreters only. Coverage Coverage is performed after the full testing cycle. The latest coverage report is available . Tools for Screencast Recording Another shell which might be useful is shell-screencast . This would build the full set of Litrepl tools and makes sure that the screencasting software is available. To enter it, specify its Nix-flake path as follows: $ nix develop '.#shell-screencast' In the opened shell, run the screencast.sh and wait a second, until the script arranges demo and recorder wondows. $ screencast.sh screencast.sh accepts an optional parameter specifying the template file to open for the recording session. Other Development Scenarios The top-level Makefile encodes common development scenarios: [ LitREPL-DEV ] $ make help LitREPL is a macroprocessing Python library for Litrate programming and code execution Build targets: dist: Build Python and Vim packages docs: Build the MkDocs documentation examples: Build examples help: Print help man: Build a manpage paper-md: Check and compile the paper PDF out of its Markdown source using JOSS tools paper-quick: Compile the paper PDF out of its LaTeX source without re-evaluation paper: Check and compile the paper PDF out of its LaTeX source readme: Update code sections in the README.md test-small: Run tests script using just the current Python and Shell interpreters test: Run tests script using all available interpreters upload: Upload Python wheel to Pypi.org (./_token.pypi is required) version: Print the version vimbundle: Build Vim bundle wheel: Build Python wheel (the DEFAULT target) Github CI The .github/workflows/testing.yaml rule set instructs Github CI to run the set of test-small tests for some versions of Python interpreter. The badge on the main page highlightes the CI status. Technical Insights The following events should normally happen after users type the :LitEval1 command: On the first run, LitREPL starts the Python interpreter in the background. Its standard input and output are redirected into UNIX pipes in the current directory. LitREPL runs the whole document through the express Markdown/Latex parser determining the start/stop positions of code and result sections. The cursor position is also available and the code from the right code section can reach the interpreter. The process which reads the interpreter's response is forked out of the main LitREPL process. The output goes to the temporary file. If the interpreter reports the completion quickly, the output is pasted to the resulting document immediately. Otherwise, the temporary results are pasted. Re-evaluating sections with temporary results causes LitREPL to update these results. Known Limitations Formatting: Nested code sections are not supported. ~~Formatting: Special symbols in the Python output could invalidate the document~~. Interpreter: Extra newline is required after Python function definitions. Interpreter: Stdout and stderr are joined together. ~~Interpreter: Evaluation of a code section locks the editor~~. Interpreter: Tweaking os.ps1 / os.ps2 prompts of the Python interpreter could break the session. ~~Interpreter: No asynchronous code execution.~~ ~~Interpreter: Background Python interpreter couldn't be interrupted~~ ~~ Bad PDF fonts in Firefox ~~","title":"Development"},{"location":"development/#development","text":"Litrepl uses Nix as its main development framework. The file flake.nix manages the source-level dependencies required by Nix, whereas default.nix specifies common build targets, including PyPI and Vim packages, demo Vim configurations, development shells, and more.","title":"Development"},{"location":"development/#contributing","text":"The original author used his favorite Python coding style for this project, the following guidelines are applied: Use 2-space indentation for everything. Use CamelCase for class names and snake_case for function names Use explicit from <module> import <function> rather than import <module> for importing. Insert type annotations where possible, use old-style upper-case type names from the typing module. Avoid spaces where possible with the following exceptions: Import name lists Function argument declarations","title":"Contributing"},{"location":"development/#building-nix-targets","text":"To build individual Nix expressions, execute the command nix build '.#NAME' , replacing NAME with the actual name of the Nix expression you want to build. If the build is successful, Nix places the results of the last build in a symbolic link located at ./result . For example, to build a version of Vim pre-configured for demo, run $ nix build '.#vim-demo' $ ./result/bin/vim-demo # Run the pre-configured demo instance of Vim The list of Nix build targets includes: litrepl-release - Litrepl script and Python lib litrepl-release-pypi - Litrepl script and Python lib vim-litrepl-release - Vim with locally built litrepl plugin vim-litrepl-release-pypi - Vim with litrepl plugin built from PYPI vim-test - A minimalistic Vim with a single litrepl plugin vim-demo - Vim configured to use litrepl suitable for recording screencasts. Uses the latest released version of Litrepl rather than the current revision. vim-plug - Vim configured to use litrepl via the Plug manager shell-dev - The development shell shell-screencast - The shell for recording demonstrations, includes vim-demo . See the local.collection attribute-set in the default.nix for the full list of defined targets. Note: The default development shell shell-dev installs many dependencies, the users are encouraged to define their own shells when needed.","title":"Building Nix Targets"},{"location":"development/#development-environments-and-setup","text":"The default development shell is defined in the ./default.nix as a Nix expression named shell which is the default name for development shells. Running $ nix develop will ask Nix to install the development dependencies and open the shell.","title":"Development Environments and Setup"},{"location":"development/#testing","text":"The runtests.sh script runs all tests by default, but accepts command-line arguments for running specific tests. Note, that Litrepl distinguishes the Python interpreter use to run the litrepl script ( -p argument) from the Python interpreters used to run the code sections ( -i argument). By default, ./runtest.sh runs the litrepl script with the python interpreter (whatever it is, leaving the OS to decide) and iterates over all visible Python interpreters for running code sections. [ LitREPL-DEV ] $ runtests.sh --help Usage: runtest.sh [-d] [-i I(,I)*] [-t T(,T)*] Arguments: -d Be very verbose -i I, --interpreters=I Run tests requiring interpreters matching the grep expression I Run -i '?' to list all available interpreters -t T, --tests=T Run tests whose names match the grep expression T Run -t '?' to list all available tests -p P, --python=P Use this Python interpreter to run Litrepl Run -p '?' to list available python interpreters -c FILE, --coverage=FILE Collect coverage results into the FILE. Defaults to `.coverage` if no tests or interpreters are selected, otherwize disabled. -c -, --coverage=- Disable coverage. Examples: runtests.sh -t '?' -i '?' runtests.sh -i ipython runtests.sh -t 'test_eval_code|test_status' -i python The project Makefile provides a couple of phony targets for testing: make test runs the testing with all default parameters (effectively checking all visible Python interpreters), while the make test-small makes a run with the default system Python and IPython interpreters only.","title":"Testing"},{"location":"development/#coverage","text":"Coverage is performed after the full testing cycle. The latest coverage report is available .","title":"Coverage"},{"location":"development/#tools-for-screencast-recording","text":"Another shell which might be useful is shell-screencast . This would build the full set of Litrepl tools and makes sure that the screencasting software is available. To enter it, specify its Nix-flake path as follows: $ nix develop '.#shell-screencast' In the opened shell, run the screencast.sh and wait a second, until the script arranges demo and recorder wondows. $ screencast.sh screencast.sh accepts an optional parameter specifying the template file to open for the recording session.","title":"Tools for Screencast Recording"},{"location":"development/#other-development-scenarios","text":"The top-level Makefile encodes common development scenarios: [ LitREPL-DEV ] $ make help LitREPL is a macroprocessing Python library for Litrate programming and code execution Build targets: dist: Build Python and Vim packages docs: Build the MkDocs documentation examples: Build examples help: Print help man: Build a manpage paper-md: Check and compile the paper PDF out of its Markdown source using JOSS tools paper-quick: Compile the paper PDF out of its LaTeX source without re-evaluation paper: Check and compile the paper PDF out of its LaTeX source readme: Update code sections in the README.md test-small: Run tests script using just the current Python and Shell interpreters test: Run tests script using all available interpreters upload: Upload Python wheel to Pypi.org (./_token.pypi is required) version: Print the version vimbundle: Build Vim bundle wheel: Build Python wheel (the DEFAULT target)","title":"Other Development Scenarios"},{"location":"development/#github-ci","text":"The .github/workflows/testing.yaml rule set instructs Github CI to run the set of test-small tests for some versions of Python interpreter. The badge on the main page highlightes the CI status.","title":"Github CI"},{"location":"development/#technical-insights","text":"The following events should normally happen after users type the :LitEval1 command: On the first run, LitREPL starts the Python interpreter in the background. Its standard input and output are redirected into UNIX pipes in the current directory. LitREPL runs the whole document through the express Markdown/Latex parser determining the start/stop positions of code and result sections. The cursor position is also available and the code from the right code section can reach the interpreter. The process which reads the interpreter's response is forked out of the main LitREPL process. The output goes to the temporary file. If the interpreter reports the completion quickly, the output is pasted to the resulting document immediately. Otherwise, the temporary results are pasted. Re-evaluating sections with temporary results causes LitREPL to update these results.","title":"Technical Insights"},{"location":"development/#known-limitations","text":"Formatting: Nested code sections are not supported. ~~Formatting: Special symbols in the Python output could invalidate the document~~. Interpreter: Extra newline is required after Python function definitions. Interpreter: Stdout and stderr are joined together. ~~Interpreter: Evaluation of a code section locks the editor~~. Interpreter: Tweaking os.ps1 / os.ps2 prompts of the Python interpreter could break the session. ~~Interpreter: No asynchronous code execution.~~ ~~Interpreter: Background Python interpreter couldn't be interrupted~~ ~~ Bad PDF fonts in Firefox ~~","title":"Known Limitations"},{"location":"installation/","text":"Installation The Github repository hosts the Litrepl tool, a standalone command-line application and an interface plugin for the Vim editor. The author's preferred installation method is using Nix, if you choose not to use it, you'll need to install one or both components separately. Below, we outline several common installation methods. For the installation of Litrepl Vim plugin, which is also a part of the project, check the Vim plugin section. Requirements POSIX-compatible OS , typically a Linux. The tool relies on POSIX operations, notably pipes, and depends on certain Shell commands. lark-parser and psutil Python packages. These should be handled automatically by the below installation methods. Socat (Optional) Needed for litrepl repl and Vim's LTerm commands to work. In most operating systems Socat should be installed separately. Installing release versions from Pypi Install the latest Litrepl from Pypi repository sh $ pip install litrepl Optionally, install the socat tool using your system package manager. Installing latest versions from Git using Pip Install the litrepl Python package with pip: sh $ pip install --user git+https://github.com/sergei-mironov/litrepl Optionally, install the socat tool using your system package manager. For more development dependencies, check the sh/install_deps_ubuntu.sh in the source code repository. Installing latest versions from source using Nix The repository offers a suite of Nix expressions designed to optimize installation and development processes on systems that support Nix. Consistent with standard practices in Nix projects, the flake.nix file defines the source dependencies, while the default.nix file identifies the targets Nix expressions. For testing, the vim-demo expression is a practical choice. It includes a pre-configured Vim setup with several related plugins, including Litrepl. Once the build is complete, you can run the Vim editor using the ./result/bin/vim-demo command. Note that vim-demo fetches the latest released version of Litrepl, not the current commit. The overall procedure looks as follows: $ git clone https://github.com/sergei-mironov/litrepl $ cd litrepl $ nix build '.#vim-demo' # ... Nix builds Litrepl and a pre-configured Vim editor. $ ./result/bin/vim-demo To build the current release version of Litrepl, build the litrepl-release target. The ./result will point to the Litrepl tree ready to be merged into a Nix profile. $ nix build '.#litrepl-release' $ ./result/bin/litrepl --version # ... Wiring Litrepl to your NixOS system depends on your particular system's organisation. Typically, for updating system profile, first include the Litrepl flake in your system flake as an input. Then, add the litrepl-release expression to environment.systemPackages or to your custom environment. # File: flake.nix inputs = { # ... vim-litrepl = { url = \"github:sergei-mironov/litrepl.vim\"; # Also consider wiring your system \"nixpkgs\" input # inputs.nixpkgs.follows = \"nixpkgs\"; }; # ... } # File: configuration.nix environment.systemPackages = with pkgs; [ # ... vim-litrepl.litrepl-release # ... ]; Nix will manage all necessary dependencies automatically. For the full list of expressions which includes developement shells, see the Development section. Installing latest versions from source using Pip The Litrepl application might be installed with pip install . run from the project root folder. Notes Optional Socat tool The Nix-powered installation methods install the Socat tool automatically. For other installation methods, use your system package manager to install it. For example, Ubuntu users might run sudo apt-get install socat . Python interpreters The Python interpreter is usually installed by default, along with the pip installer. To install ipython , you can use pip install ipython . Aicli interpreter A GNU Readline-based application for interacting with chat-oriented AI models, which Litrep supports as the interpret for ai code sections. For the details, please check the aicli project page. Typically, you can install it with pip install sm_aicli .","title":"Installation"},{"location":"installation/#installation","text":"The Github repository hosts the Litrepl tool, a standalone command-line application and an interface plugin for the Vim editor. The author's preferred installation method is using Nix, if you choose not to use it, you'll need to install one or both components separately. Below, we outline several common installation methods. For the installation of Litrepl Vim plugin, which is also a part of the project, check the Vim plugin section.","title":"Installation"},{"location":"installation/#requirements","text":"POSIX-compatible OS , typically a Linux. The tool relies on POSIX operations, notably pipes, and depends on certain Shell commands. lark-parser and psutil Python packages. These should be handled automatically by the below installation methods. Socat (Optional) Needed for litrepl repl and Vim's LTerm commands to work. In most operating systems Socat should be installed separately.","title":"Requirements"},{"location":"installation/#installing-release-versions-from-pypi","text":"Install the latest Litrepl from Pypi repository sh $ pip install litrepl Optionally, install the socat tool using your system package manager.","title":"Installing release versions from Pypi"},{"location":"installation/#installing-latest-versions-from-git-using-pip","text":"Install the litrepl Python package with pip: sh $ pip install --user git+https://github.com/sergei-mironov/litrepl Optionally, install the socat tool using your system package manager. For more development dependencies, check the sh/install_deps_ubuntu.sh in the source code repository.","title":"Installing latest versions from Git using Pip"},{"location":"installation/#installing-latest-versions-from-source-using-nix","text":"The repository offers a suite of Nix expressions designed to optimize installation and development processes on systems that support Nix. Consistent with standard practices in Nix projects, the flake.nix file defines the source dependencies, while the default.nix file identifies the targets Nix expressions. For testing, the vim-demo expression is a practical choice. It includes a pre-configured Vim setup with several related plugins, including Litrepl. Once the build is complete, you can run the Vim editor using the ./result/bin/vim-demo command. Note that vim-demo fetches the latest released version of Litrepl, not the current commit. The overall procedure looks as follows: $ git clone https://github.com/sergei-mironov/litrepl $ cd litrepl $ nix build '.#vim-demo' # ... Nix builds Litrepl and a pre-configured Vim editor. $ ./result/bin/vim-demo To build the current release version of Litrepl, build the litrepl-release target. The ./result will point to the Litrepl tree ready to be merged into a Nix profile. $ nix build '.#litrepl-release' $ ./result/bin/litrepl --version # ... Wiring Litrepl to your NixOS system depends on your particular system's organisation. Typically, for updating system profile, first include the Litrepl flake in your system flake as an input. Then, add the litrepl-release expression to environment.systemPackages or to your custom environment. # File: flake.nix inputs = { # ... vim-litrepl = { url = \"github:sergei-mironov/litrepl.vim\"; # Also consider wiring your system \"nixpkgs\" input # inputs.nixpkgs.follows = \"nixpkgs\"; }; # ... } # File: configuration.nix environment.systemPackages = with pkgs; [ # ... vim-litrepl.litrepl-release # ... ]; Nix will manage all necessary dependencies automatically. For the full list of expressions which includes developement shells, see the Development section.","title":"Installing latest versions from source using Nix"},{"location":"installation/#installing-latest-versions-from-source-using-pip","text":"The Litrepl application might be installed with pip install . run from the project root folder.","title":"Installing latest versions from source using Pip"},{"location":"installation/#notes","text":"","title":"Notes"},{"location":"installation/#optional-socat-tool","text":"The Nix-powered installation methods install the Socat tool automatically. For other installation methods, use your system package manager to install it. For example, Ubuntu users might run sudo apt-get install socat .","title":"Optional Socat tool"},{"location":"installation/#python-interpreters","text":"The Python interpreter is usually installed by default, along with the pip installer. To install ipython , you can use pip install ipython .","title":"Python interpreters"},{"location":"installation/#aicli-interpreter","text":"A GNU Readline-based application for interacting with chat-oriented AI models, which Litrep supports as the interpret for ai code sections. For the details, please check the aicli project page. Typically, you can install it with pip install sm_aicli .","title":"Aicli interpreter"},{"location":"reference/","text":"Command Reference Vim Commands and Command-Line Attributes Vim Command line Description :LStart [T] litrepl start [T] Start the background interpreter :LStop [T] litrepl stop [T] Stop the background interpreter :LRestart [T] litrepl restart [T] Restart the background interpreter :LStatus [T] litrepl status [T] <F Print the background interpreter status :LEval [N] lirtepl eval-sections L:C <F Evaluate the section under the cursor synchronously :LEval above lirtepl eval-sections '0..N' <F Evaluate sections above and under the cursor synchronously :LEval below lirtepl eval-sections 'N..$' <F Evaluate sections below and under the cursor synchronously :LEval all lirtepl eval-sections <F Evaluate all code sections in a document :LEvalAsync N lirtepl --timeout=0.5,0 eval-sections N <F Start or continue asynchronous evaluation of the section under the cursor :LInterrupt N lirtepl interrupt N <F Send SIGINT to the interpreter evaluating the section under the cursor and update :LEvalMon N while .. do .. done Start or continue monitoring asynchronous code evaluation N/A lirtepl eval-code <P Evaluate the given code verbatim :LTerm [T] lirtepl repl [T] Connect to the interpreter using GNU socat :LOpenErr litrepl ... 2>F View errors :LVersion litrepl --version Show version Where T Type of the interpreter: python , ai or sh (some commands also accept all ) F Path to a Markdown or LaTeX file P Path to a Python script N Number of code section to evaluate, starting from 0. L:C denotes line:column of the cursor. Command Line Arguments and Vim Variables Vim setting CLI argument Description set filetype --filetype=T Input file type: latex | markdown let g:litrepl_python_interpreter=B --python-interpreter=B The Python interpreter to use let g:litrepl_ai_interpreter=B --ai-interpreter=B The AI interpreter to use let g:litrepl_sh_interpreter=B --sh-interpreter=B The shell interpreter to use let g:litrepl_python_auxdir=D --python-auxdir=D The auxiliary files directory used by Python interpreter let g:litrepl_ai_auxdir=D --ai-auxdir=D The auxiliary files directory used by AI interpreter let g:litrepl_sh_auxdir=D --sh-auxdir=D The auxiliary files directory used by a shell interpreter let g:litrepl_workdir=D --workdir=D The auxiliary files directory used by AI interpreter let g:litrepl_debug=0/1 --debug=0/1 Print debug messages to the stderr let g:litrepl_timeout=FLOAT --timeout=FLOAT Timeout to wait for the new executions, in seconds, defaults to inf T Type of the document: tex or markdown (the default). B Interpreter command to use, - or auto (the default). - value disabled this type of interpreters; auto asks litrep to guess the best available interpreter. D Filesystem directory FLOAT Should be formatted as 1 or 1.1 or inf . Note: command line argument also accepts a pair of timeouts. Command Line Arguments Summary usage: litrepl [-h] [-v] [--filetype STR] [--python-markers STR[,STR]] [--ai-markers STR[,STR]] [--sh-markers STR[,STR]] [--python-interpreter EXE] [--ai-interpreter EXE] [--sh-interpreter EXE] [--python-auxdir DIR] [--ai-auxdir DIR] [--sh-auxdir DIR] [--timeout F[,F]] [--propagate-sigint] [-d INT] [-K] [--verbose] [-C DIR] [--pending-exitcode INT] [--irreproducible-exitcode INT] [--exception-exitcode INT] [--foreground] [--map-cursor LINE:COL:FILE] [--result-textwidth NUM] {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} ... positional arguments: {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} Commands to execute start Start a background interpreter. The CLASS of an interpreter should be specified. --<CLASS>-interpreter, --<CLASS>-auxdir etc. are applied. stop Stop the background interpreters. restart Restart the background interpreters. status Print background interpreter's status. parse Parse the input file without futher processing (diagnostics). parse-print Parse and print the input file back (diagnostics). eval-sections Do `start` if needed, Parse stdin, evaluate the specified sections (by default - all available sections), print the resulting file to stdout. eval-code Evaluate the code snippet. repl Connect to the background terminal using GNU socat. interrupt Send SIGINT to the background interpreter. print-regexp Print regexp matching start of code sections for the given file type. print-grammar Print the resulting grammar for the given filetype. print-auxdir Print the auxdir for the given interpreter type. options: -h, --help show this help message and exit -v, --version Print version. --filetype STR Specify the type of input formatting (markdown|[la]tex|auto). --python-markers STR[,STR] Specify section markers recognized as `python` sections. Defaults to the value of LITREPL_PYTHON_MARERS if set, otherwize \"python\". --ai-markers STR[,STR] Specify section markers recognized as `ai` sections. Defaults to the value of LITREPL_AI_MARERS if set, otherwize \"codeai,ai\". --sh-markers STR[,STR] Specify section markers recognized as `shell` sections. Defaults to the value of LITREPL_SH_MARERS if set, otherwize \"shell\". --python-interpreter EXE Python interpreter command line, or `auto`. Defaults to the LITREPL_PYTHON_INTERPRETER environment variable if set, otherwise \"auto\". Litrepl determines \"python\" or \"ipython\" type according to the value. --ai-interpreter EXE `aicli` interpreter command line or `auto`. Defaults to the LITREPL_AI_INTERPRETER environment variable if set, otherwise \"auto\". --sh-interpreter EXE Shell interpreter command line or `auto`. Defaults to the LITREPL_SH_INTERPRETER environment variable if set, otherwise \"auto\". --python-auxdir DIR This directory stores Python interpreter pipes. It defaults to LITREPL_PYTHON_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --ai-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_AI_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --sh-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_SH_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --timeout F[,F] Timeouts for initial evaluation and for pending checks, in seconds. If the latter is omitted, it is considered to be equal to the former one. --propagate-sigint If set, litrepl will catch and resend SIGINT signals to the running interpreter. Otherwise it will just terminate itself leaving the interpreter as-is. -d INT, --debug INT Enable (a lot of) debug messages. -K, --keep-readout Do not delete temporary readout file (debugging). --verbose Be more verbose (used in status). -C DIR, --workdir DIR Set the working directory before execution. By default, it uses LITREPL_WORKDIR if set, otherwise remains the current directory. This affects the directory of a new interpreter and the --<interpreter>-auxdir option. --pending-exitcode INT Return this error code if whenever a section hits timeout. --irreproducible-exitcode INT Return this error code if a section outputs a different result than the one that is already present in the document. --exception-exitcode INT Return this error code at exception, if any. Note: this option might not be defined for some interpreters. It takes affect only for newly- started interpreters. --foreground Start a separate session and stop it when the evaluation is done. All --*-auxdir settings are ignored in this mode. --map-cursor LINE:COL:FILE Calculate the new position of a cursor at LINE:COL and write it to FILE. --result-textwidth NUM Wrap result lines longer than NUM symbols.","title":"Reference"},{"location":"reference/#command-reference","text":"","title":"Command Reference"},{"location":"reference/#vim-commands-and-command-line-attributes","text":"Vim Command line Description :LStart [T] litrepl start [T] Start the background interpreter :LStop [T] litrepl stop [T] Stop the background interpreter :LRestart [T] litrepl restart [T] Restart the background interpreter :LStatus [T] litrepl status [T] <F Print the background interpreter status :LEval [N] lirtepl eval-sections L:C <F Evaluate the section under the cursor synchronously :LEval above lirtepl eval-sections '0..N' <F Evaluate sections above and under the cursor synchronously :LEval below lirtepl eval-sections 'N..$' <F Evaluate sections below and under the cursor synchronously :LEval all lirtepl eval-sections <F Evaluate all code sections in a document :LEvalAsync N lirtepl --timeout=0.5,0 eval-sections N <F Start or continue asynchronous evaluation of the section under the cursor :LInterrupt N lirtepl interrupt N <F Send SIGINT to the interpreter evaluating the section under the cursor and update :LEvalMon N while .. do .. done Start or continue monitoring asynchronous code evaluation N/A lirtepl eval-code <P Evaluate the given code verbatim :LTerm [T] lirtepl repl [T] Connect to the interpreter using GNU socat :LOpenErr litrepl ... 2>F View errors :LVersion litrepl --version Show version Where T Type of the interpreter: python , ai or sh (some commands also accept all ) F Path to a Markdown or LaTeX file P Path to a Python script N Number of code section to evaluate, starting from 0. L:C denotes line:column of the cursor.","title":"Vim Commands and Command-Line Attributes"},{"location":"reference/#command-line-arguments-and-vim-variables","text":"Vim setting CLI argument Description set filetype --filetype=T Input file type: latex | markdown let g:litrepl_python_interpreter=B --python-interpreter=B The Python interpreter to use let g:litrepl_ai_interpreter=B --ai-interpreter=B The AI interpreter to use let g:litrepl_sh_interpreter=B --sh-interpreter=B The shell interpreter to use let g:litrepl_python_auxdir=D --python-auxdir=D The auxiliary files directory used by Python interpreter let g:litrepl_ai_auxdir=D --ai-auxdir=D The auxiliary files directory used by AI interpreter let g:litrepl_sh_auxdir=D --sh-auxdir=D The auxiliary files directory used by a shell interpreter let g:litrepl_workdir=D --workdir=D The auxiliary files directory used by AI interpreter let g:litrepl_debug=0/1 --debug=0/1 Print debug messages to the stderr let g:litrepl_timeout=FLOAT --timeout=FLOAT Timeout to wait for the new executions, in seconds, defaults to inf T Type of the document: tex or markdown (the default). B Interpreter command to use, - or auto (the default). - value disabled this type of interpreters; auto asks litrep to guess the best available interpreter. D Filesystem directory FLOAT Should be formatted as 1 or 1.1 or inf . Note: command line argument also accepts a pair of timeouts.","title":"Command Line Arguments and Vim Variables"},{"location":"reference/#command-line-arguments-summary","text":"usage: litrepl [-h] [-v] [--filetype STR] [--python-markers STR[,STR]] [--ai-markers STR[,STR]] [--sh-markers STR[,STR]] [--python-interpreter EXE] [--ai-interpreter EXE] [--sh-interpreter EXE] [--python-auxdir DIR] [--ai-auxdir DIR] [--sh-auxdir DIR] [--timeout F[,F]] [--propagate-sigint] [-d INT] [-K] [--verbose] [-C DIR] [--pending-exitcode INT] [--irreproducible-exitcode INT] [--exception-exitcode INT] [--foreground] [--map-cursor LINE:COL:FILE] [--result-textwidth NUM] {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} ... positional arguments: {start,stop,restart,status,parse,parse-print,eval-sections,eval-code,repl,interrupt,print-regexp,print-grammar,print-auxdir} Commands to execute start Start a background interpreter. The CLASS of an interpreter should be specified. --<CLASS>-interpreter, --<CLASS>-auxdir etc. are applied. stop Stop the background interpreters. restart Restart the background interpreters. status Print background interpreter's status. parse Parse the input file without futher processing (diagnostics). parse-print Parse and print the input file back (diagnostics). eval-sections Do `start` if needed, Parse stdin, evaluate the specified sections (by default - all available sections), print the resulting file to stdout. eval-code Evaluate the code snippet. repl Connect to the background terminal using GNU socat. interrupt Send SIGINT to the background interpreter. print-regexp Print regexp matching start of code sections for the given file type. print-grammar Print the resulting grammar for the given filetype. print-auxdir Print the auxdir for the given interpreter type. options: -h, --help show this help message and exit -v, --version Print version. --filetype STR Specify the type of input formatting (markdown|[la]tex|auto). --python-markers STR[,STR] Specify section markers recognized as `python` sections. Defaults to the value of LITREPL_PYTHON_MARERS if set, otherwize \"python\". --ai-markers STR[,STR] Specify section markers recognized as `ai` sections. Defaults to the value of LITREPL_AI_MARERS if set, otherwize \"codeai,ai\". --sh-markers STR[,STR] Specify section markers recognized as `shell` sections. Defaults to the value of LITREPL_SH_MARERS if set, otherwize \"shell\". --python-interpreter EXE Python interpreter command line, or `auto`. Defaults to the LITREPL_PYTHON_INTERPRETER environment variable if set, otherwise \"auto\". Litrepl determines \"python\" or \"ipython\" type according to the value. --ai-interpreter EXE `aicli` interpreter command line or `auto`. Defaults to the LITREPL_AI_INTERPRETER environment variable if set, otherwise \"auto\". --sh-interpreter EXE Shell interpreter command line or `auto`. Defaults to the LITREPL_SH_INTERPRETER environment variable if set, otherwise \"auto\". --python-auxdir DIR This directory stores Python interpreter pipes. It defaults to LITREPL_PYTHON_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --ai-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_AI_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --sh-auxdir DIR This directory stores AI interpreter pipes. It defaults to LITREPL_SH_AUXDIR if set; otherwise, it's created in the system's temporary directory, named after the current working directory. --timeout F[,F] Timeouts for initial evaluation and for pending checks, in seconds. If the latter is omitted, it is considered to be equal to the former one. --propagate-sigint If set, litrepl will catch and resend SIGINT signals to the running interpreter. Otherwise it will just terminate itself leaving the interpreter as-is. -d INT, --debug INT Enable (a lot of) debug messages. -K, --keep-readout Do not delete temporary readout file (debugging). --verbose Be more verbose (used in status). -C DIR, --workdir DIR Set the working directory before execution. By default, it uses LITREPL_WORKDIR if set, otherwise remains the current directory. This affects the directory of a new interpreter and the --<interpreter>-auxdir option. --pending-exitcode INT Return this error code if whenever a section hits timeout. --irreproducible-exitcode INT Return this error code if a section outputs a different result than the one that is already present in the document. --exception-exitcode INT Return this error code at exception, if any. Note: this option might not be defined for some interpreters. It takes affect only for newly- started interpreters. --foreground Start a separate session and stop it when the evaluation is done. All --*-auxdir settings are ignored in this mode. --map-cursor LINE:COL:FILE Calculate the new position of a cursor at LINE:COL and write it to FILE. --result-textwidth NUM Wrap result lines longer than NUM symbols.","title":"Command Line Arguments Summary"},{"location":"related/","text":"Related Tools and Projects Edititng: https://github.com/lervag/vimtex (LaTeX editing, LaTeX preview) https://github.com/shime/vim-livedown (Markdown preview) https://github.com/preservim/vim-markdown (Markdown editing) Code execution: Vim-medieval https://github.com/gpanders/vim-medieval Evaluates Markdown code sections Pyluatex https://www.ctan.org/pkg/pyluatex Magma-nvim https://github.com/dccsillag/magma-nvim Codi https://github.com/metakirby5/codi.vim Pythontex https://github.com/gpoore/pythontex Evaluates Latex code sections Codebraid https://github.com/gpoore/codebraid Vim-ipython-cell https://github.com/hanschen/vim-ipython-cell Vim-ipython https://github.com/ivanov/vim-ipython Jupytext https://github.com/goerz/jupytext.vim Alternative? https://github.com/mwouts/jupytext Ipython-vimception https://github.com/ivanov/ipython-vimception Considerations for Third-Party Tools Vim-plug https://github.com/junegunn/vim-plug/issues/1010#issuecomment-1221614232 Pandoc https://github.com/jgm/pandoc/issues/8598 Jupytext https://github.com/mwouts/jupytext/issues/220#issuecomment-1418209581 Vim-LSC https://github.com/natebosch/vim-lsc/issues/469","title":"Related"},{"location":"related/#related","text":"","title":"Related"},{"location":"related/#tools-and-projects","text":"Edititng: https://github.com/lervag/vimtex (LaTeX editing, LaTeX preview) https://github.com/shime/vim-livedown (Markdown preview) https://github.com/preservim/vim-markdown (Markdown editing) Code execution: Vim-medieval https://github.com/gpanders/vim-medieval Evaluates Markdown code sections Pyluatex https://www.ctan.org/pkg/pyluatex Magma-nvim https://github.com/dccsillag/magma-nvim Codi https://github.com/metakirby5/codi.vim Pythontex https://github.com/gpoore/pythontex Evaluates Latex code sections Codebraid https://github.com/gpoore/codebraid Vim-ipython-cell https://github.com/hanschen/vim-ipython-cell Vim-ipython https://github.com/ivanov/vim-ipython Jupytext https://github.com/goerz/jupytext.vim Alternative? https://github.com/mwouts/jupytext Ipython-vimception https://github.com/ivanov/ipython-vimception","title":"Tools and Projects"},{"location":"related/#considerations-for-third-party-tools","text":"Vim-plug https://github.com/junegunn/vim-plug/issues/1010#issuecomment-1221614232 Pandoc https://github.com/jgm/pandoc/issues/8598 Jupytext https://github.com/mwouts/jupytext/issues/220#issuecomment-1418209581 Vim-LSC https://github.com/natebosch/vim-lsc/issues/469","title":"Considerations for Third-Party Tools"},{"location":"examples/basic/","text":"print('Hello Markdown!')","title":"Basic"},{"location":"examples/example/","text":"Executable sections are marked with the \"python\" tag. Putting the cursor on one of the typing the :LitEval1 command executes its code in a background Python interpreter. W='Hello, World!' print(W) Verbatim sections next to the executable section are result sections. Litrepl pastes the result here during the evaluation. The original content of this section is replaced. Hello, World! Markdown comment-looking tags result / noresult also mark executable and result sections. They allow to generate the Markdown document markup. Hello, LitREPL","title":"Example"},{"location":"static/description/","text":"command-line processor for Markdown or LaTeX documents with literate programming code sections. Instructed by its arguments, it evaluates and updates sections via background interpreters. Interpreters can stay active for a read-eval-paste-loop style.","title":"Description"},{"location":"usage/application-scenarios/","text":"Application Scenarios Command Line, Foreground Evaluation When performing batch processing of documents, it might be necessary to initiate a new interpreter session solely for the evaluation's duration rather than re-using the currently running session. The --foreground option can be used to activate this mode. $ cat document.md.in | litrepl --foreground eval-sections > document.md Command Line, Detecting Python Exceptions Another frequently requested feature is the ability to report unhandled exceptions. Litrepl can be configured to return a non-zero exit code in such scenarios. $ cat document.md ``` python raise Exception(\"D'oh!\") ``` $ cat document.md | litrepl --foreground --exception-exit=200 eval-sections $ echo $? 200 In this example, the --foreground option instructs Litrepl to start a new interpreter session, stopping it upon completion. The --exception-exit=200 option specifies the exit code to be returned in the event of unhandled exceptions. Command Line, Running Remote Interpreters Over SSH Litrepl supports running interpreters over SSH on a remote machine. In order to do so, one needs to create a shell script establishing the communication and name it in a recognizable way. For example, consider the case where we edit a local document but all sections that we want to execute should be run on a remote machine named testbed . We prepare an executable script named ipython-testbed.sh and put it into a directory listed in the PATH environment variable. The contents of the script is the following: #!/bin/sh exec ssh testbed -p 22 -- bash --login -c ipython \"$@\" Now, we can process our document as usual, but add ipython-testbed.sh as a new IPython interpreter: # Executes code sections on a remote machine. cat README.md | litrepl --python-interpreter=ipython-testbed.sh Note that the string ipython must appear in the interpreter name, to let Litrepl exercise IPyhton-specific communication settings. Command Line, Converting formatted Markdown to Jupyter Notebook Pandoc could be used to conver LitREPL-formatted markdown documents to the Jupyter Notebook format. In order to make it recognize the code and result fields, addtional formatting is required. Currently we aware of two options: Using fenced Markdown syntax extension Mark Jupyter sections with fenced-div markup as described in the Pandoc manual . Consider the following file.md : :::::: {.cell .code execution_count=1} ```python print(\"Hello Jupyter!\") ``` ::: {.output .stream .stdout} ``` result Hello Jupyter! ``` ::: :::::: The above format is recognized by both Litrepl and Pandoc , so to convert it to the Jupyter Notebook format one may run: $ pandoc file.md -o file.ipynb Unfortunately, other renderers may interpret fenced divs incorrectly. Using Native divs syntax extension Alternatively, native divs syntax extension could be used. Consider the following file.md file: <div class=\"cell code\"> ```python print(\"Hello Jupyter!\") ``` <div class=\"output stream stdout\"> ```result Hello Jupyter! ``` </div> </div> Both Litrepl and Pandoc will recognize this format, plus most third-party renderers will ignore div tags. The downside of this approach is the fact that pandoc now needs native divs extension to convert the document: $ pandoc -f markdown+native_divs file.md -o test.ipynb GNU Make, Evaluating Code Sections in Project Documentation A typical Makefile recipe for updating documentation is structured as follows: SRC = $(shell find -name '*\\.py') .stamp_readme: $(SRC) Makefile cp README.md _README.md.in cat _README.md.in | \\ litrepl --foreground --exception-exit=100 \\ --python-interpreter=ipython \\ --sh-interpreter=- \\ eval-sections >README.md touch $@ .PHONY: readme readme: .stamp_readme Here, $(SRC) is expected to include the filenames of dependencies. With this recipe, we can run make readme to evaluate the python sections. By passing - wealso tell Litrepl to ignore shell sections. Vim, Setting Up Keybindings The litrepl.vim plugin does not define any keybindings, but users could do it by themselves, for example: nnoremap <F5> :LEval<CR> nnoremap <F6> :LEvalAsync<CR> Vim, Inserting New Sections The litrepl.vim plugin doesn't include tools for creating section formatting, however they can be added easily if required. Below, we demonstrate how to define the :C command inserting new python sections. command! -buffer -nargs=0 C normal 0i``` python<CR>```<CR><CR>``` result<CR>```<Esc>4k Vim, Running the Initial Section After Interpreter Restart Below we demonstrate how to define the :LR command for running first section after the restart. command! -nargs=0 LR LRestart | LEval 0 Vim, Evaluating Selected Text Litrepl vim plugin defines LitReplEvalSelection function which runs the selection as a virtual code section. The section type is passed as the function argument. For example, calling LitReplEvalSelection('ai') will execute the selection as if it is an ai code section. The execution result is pasted right after the selection as a plain text. LitReplEvalSelection('python') would pipe the selection through the current Python interpreter. To use the feature, define a suitable key binding ( Ctrl+K in this example), vnoremap <C-k> :call LitReplEvalSelection('ai')<CR> Now write a question to the AI in any document, select it and hit Ctrl+K. Hi model. What is the capital of New Zealand? Upon the keypress, Litrepl pipes the selection through the AI interpreter - the aicli at the time of this writing - and paste the response right after the last line of the original selection. Hi model. What is the capital of New Zealand? The capital of New Zealand is Wellington. Internally, the plugin just uses eval-code Litrepl command. Vim, Calling for AI on a visual selection Note: litrepl_extras.vim has been reworked since 3.14.0. Note: this is not stable and a subject to change. The repository includes litrepl_extras.vim , which defines a generic interface for external text\u2011rewriting tools. While it can work with a variety of backends, it is primarily designed to integrate smoothly with Aicli sessions powered by Litrepl. The litrepl_extras.vim defines the following Vim commands: :LPush[!] <script> <prompt> Calls the litrepl-<script> executable and echoes its output. :LPipe[!] <script> <prompt> pipes the selection through the litrepl-<script> executable (if there is a selection) or inserts the executable's output at the cursor position. :LPipeFile[!] <script> <prompt> pipes the current file through the litrepl-<script> executable (if there is a selection) or inserts the executable's output at the cursor position. All the above commands get translated into a command line matching the following convension (subject to change): usage: litrepl-<script> [-h] [-P PROMPT_LIST] [-s SELECTION_PASTE] [-S SELECTION_RAW] [-f OUTPUT_FORMAT] [-w TEXTWIDTH] [-v] [--location NAME LOC] [--location-raw NAME LOC] [--command COMMAND] ... positional arguments: files options: -h, --help show this help message and exit -P PROMPT_LIST, --prompt PROMPT_LIST -s SELECTION_PASTE, --selection-paste SELECTION_PASTE -S SELECTION_RAW, --selection-raw SELECTION_RAW -f OUTPUT_FORMAT, --output-format OUTPUT_FORMAT -w TEXTWIDTH, --textwidth TEXTWIDTH -v, -d, --debug, --verbose --dry-run --location NAME LOC --location-raw NAME LOC --command COMMAND The command is currently set to the fixed eval-code string literal. The bang versions of the Vim commands cause -S (disable escaping commands within the selection) to be used instead of -s (escape the selection). For Aicli this means that the /commands would be executed rather than passed to an LLM model. Users are free to write their own scripts. The completion will try to match the litrepl-* pattern to a unique match. For example, below is the example of the litrepl-grammar.sh script, which asks AI to correct the grammar of the selected text: #!/bin/sh exec litrepl-aicli.py -P \"Please correct English grammar within the 'selection'. Keep the choice of words, minimize the changes you make.\" \"$@\"","title":"Application Scenarios"},{"location":"usage/application-scenarios/#application-scenarios","text":"","title":"Application Scenarios"},{"location":"usage/application-scenarios/#command-line-foreground-evaluation","text":"When performing batch processing of documents, it might be necessary to initiate a new interpreter session solely for the evaluation's duration rather than re-using the currently running session. The --foreground option can be used to activate this mode. $ cat document.md.in | litrepl --foreground eval-sections > document.md","title":"Command Line, Foreground Evaluation"},{"location":"usage/application-scenarios/#command-line-detecting-python-exceptions","text":"Another frequently requested feature is the ability to report unhandled exceptions. Litrepl can be configured to return a non-zero exit code in such scenarios. $ cat document.md ``` python raise Exception(\"D'oh!\") ``` $ cat document.md | litrepl --foreground --exception-exit=200 eval-sections $ echo $? 200 In this example, the --foreground option instructs Litrepl to start a new interpreter session, stopping it upon completion. The --exception-exit=200 option specifies the exit code to be returned in the event of unhandled exceptions.","title":"Command Line, Detecting Python Exceptions"},{"location":"usage/application-scenarios/#command-line-running-remote-interpreters-over-ssh","text":"Litrepl supports running interpreters over SSH on a remote machine. In order to do so, one needs to create a shell script establishing the communication and name it in a recognizable way. For example, consider the case where we edit a local document but all sections that we want to execute should be run on a remote machine named testbed . We prepare an executable script named ipython-testbed.sh and put it into a directory listed in the PATH environment variable. The contents of the script is the following: #!/bin/sh exec ssh testbed -p 22 -- bash --login -c ipython \"$@\" Now, we can process our document as usual, but add ipython-testbed.sh as a new IPython interpreter: # Executes code sections on a remote machine. cat README.md | litrepl --python-interpreter=ipython-testbed.sh Note that the string ipython must appear in the interpreter name, to let Litrepl exercise IPyhton-specific communication settings.","title":"Command Line, Running Remote Interpreters Over SSH"},{"location":"usage/application-scenarios/#command-line-converting-formatted-markdown-to-jupyter-notebook","text":"Pandoc could be used to conver LitREPL-formatted markdown documents to the Jupyter Notebook format. In order to make it recognize the code and result fields, addtional formatting is required. Currently we aware of two options:","title":"Command Line, Converting formatted Markdown to Jupyter Notebook"},{"location":"usage/application-scenarios/#using-fenced-markdown-syntax-extension","text":"Mark Jupyter sections with fenced-div markup as described in the Pandoc manual . Consider the following file.md : :::::: {.cell .code execution_count=1} ```python print(\"Hello Jupyter!\") ``` ::: {.output .stream .stdout} ``` result Hello Jupyter! ``` ::: :::::: The above format is recognized by both Litrepl and Pandoc , so to convert it to the Jupyter Notebook format one may run: $ pandoc file.md -o file.ipynb Unfortunately, other renderers may interpret fenced divs incorrectly.","title":"Using fenced Markdown syntax extension"},{"location":"usage/application-scenarios/#using-native-divs-syntax-extension","text":"Alternatively, native divs syntax extension could be used. Consider the following file.md file: <div class=\"cell code\"> ```python print(\"Hello Jupyter!\") ``` <div class=\"output stream stdout\"> ```result Hello Jupyter! ``` </div> </div> Both Litrepl and Pandoc will recognize this format, plus most third-party renderers will ignore div tags. The downside of this approach is the fact that pandoc now needs native divs extension to convert the document: $ pandoc -f markdown+native_divs file.md -o test.ipynb","title":"Using Native divs syntax extension"},{"location":"usage/application-scenarios/#gnu-make-evaluating-code-sections-in-project-documentation","text":"A typical Makefile recipe for updating documentation is structured as follows: SRC = $(shell find -name '*\\.py') .stamp_readme: $(SRC) Makefile cp README.md _README.md.in cat _README.md.in | \\ litrepl --foreground --exception-exit=100 \\ --python-interpreter=ipython \\ --sh-interpreter=- \\ eval-sections >README.md touch $@ .PHONY: readme readme: .stamp_readme Here, $(SRC) is expected to include the filenames of dependencies. With this recipe, we can run make readme to evaluate the python sections. By passing - wealso tell Litrepl to ignore shell sections.","title":"GNU Make, Evaluating Code Sections in Project Documentation"},{"location":"usage/application-scenarios/#vim-setting-up-keybindings","text":"The litrepl.vim plugin does not define any keybindings, but users could do it by themselves, for example: nnoremap <F5> :LEval<CR> nnoremap <F6> :LEvalAsync<CR>","title":"Vim, Setting Up Keybindings"},{"location":"usage/application-scenarios/#vim-inserting-new-sections","text":"The litrepl.vim plugin doesn't include tools for creating section formatting, however they can be added easily if required. Below, we demonstrate how to define the :C command inserting new python sections. command! -buffer -nargs=0 C normal 0i``` python<CR>```<CR><CR>``` result<CR>```<Esc>4k","title":"Vim, Inserting New Sections"},{"location":"usage/application-scenarios/#vim-running-the-initial-section-after-interpreter-restart","text":"Below we demonstrate how to define the :LR command for running first section after the restart. command! -nargs=0 LR LRestart | LEval 0","title":"Vim, Running the Initial Section After Interpreter Restart"},{"location":"usage/application-scenarios/#vim-evaluating-selected-text","text":"Litrepl vim plugin defines LitReplEvalSelection function which runs the selection as a virtual code section. The section type is passed as the function argument. For example, calling LitReplEvalSelection('ai') will execute the selection as if it is an ai code section. The execution result is pasted right after the selection as a plain text. LitReplEvalSelection('python') would pipe the selection through the current Python interpreter. To use the feature, define a suitable key binding ( Ctrl+K in this example), vnoremap <C-k> :call LitReplEvalSelection('ai')<CR> Now write a question to the AI in any document, select it and hit Ctrl+K. Hi model. What is the capital of New Zealand? Upon the keypress, Litrepl pipes the selection through the AI interpreter - the aicli at the time of this writing - and paste the response right after the last line of the original selection. Hi model. What is the capital of New Zealand? The capital of New Zealand is Wellington. Internally, the plugin just uses eval-code Litrepl command.","title":"Vim, Evaluating Selected Text"},{"location":"usage/application-scenarios/#vim-calling-for-ai-on-a-visual-selection","text":"Note: litrepl_extras.vim has been reworked since 3.14.0. Note: this is not stable and a subject to change. The repository includes litrepl_extras.vim , which defines a generic interface for external text\u2011rewriting tools. While it can work with a variety of backends, it is primarily designed to integrate smoothly with Aicli sessions powered by Litrepl. The litrepl_extras.vim defines the following Vim commands: :LPush[!] <script> <prompt> Calls the litrepl-<script> executable and echoes its output. :LPipe[!] <script> <prompt> pipes the selection through the litrepl-<script> executable (if there is a selection) or inserts the executable's output at the cursor position. :LPipeFile[!] <script> <prompt> pipes the current file through the litrepl-<script> executable (if there is a selection) or inserts the executable's output at the cursor position. All the above commands get translated into a command line matching the following convension (subject to change): usage: litrepl-<script> [-h] [-P PROMPT_LIST] [-s SELECTION_PASTE] [-S SELECTION_RAW] [-f OUTPUT_FORMAT] [-w TEXTWIDTH] [-v] [--location NAME LOC] [--location-raw NAME LOC] [--command COMMAND] ... positional arguments: files options: -h, --help show this help message and exit -P PROMPT_LIST, --prompt PROMPT_LIST -s SELECTION_PASTE, --selection-paste SELECTION_PASTE -S SELECTION_RAW, --selection-raw SELECTION_RAW -f OUTPUT_FORMAT, --output-format OUTPUT_FORMAT -w TEXTWIDTH, --textwidth TEXTWIDTH -v, -d, --debug, --verbose --dry-run --location NAME LOC --location-raw NAME LOC --command COMMAND The command is currently set to the fixed eval-code string literal. The bang versions of the Vim commands cause -S (disable escaping commands within the selection) to be used instead of -s (escape the selection). For Aicli this means that the /commands would be executed rather than passed to an LLM model. Users are free to write their own scripts. The completion will try to match the litrepl-* pattern to a unique match. For example, below is the example of the litrepl-grammar.sh script, which asks AI to correct the grammar of the selected text: #!/bin/sh exec litrepl-aicli.py -P \"Please correct English grammar within the 'selection'. Keep the choice of words, minimize the changes you make.\" \"$@\"","title":"Vim, Calling for AI on a visual selection"},{"location":"usage/formatting/","text":"Formatting Markdown Basic syntax Executable sections are verbatim sections marked with a number of tags, including \"python\" and \"code\". ``` python W='Hello, World!' print(W) ``` Verbatim result sections might be marked as \"result\" or \"lresult\". ``` result Hello, World! ``` Markdown comments tagged with result / noresult (see an example below) also mark result sections. This syntax allows emitting parts of Markdown document. <!-- result --> Hello, World! <!-- noresult --> Latex Basic syntax Litrepl treats \\begin{python}\\end{python} environment as code sections and \\begin{result}\\end{result} environment as result sections. The names are currently hardcoded into the simplified LitREPL parser. Wrapping it in other tags is not allowed. LaTeX does not know anything about these environments by default, so we need to introduce these environments in the preamble: \\documentclass{article} \\usepackage[utf8]{inputenc} \\begin{document} \\newenvironment{python}{\\begin{texttt}}{\\end{texttt}} \\newenvironment{result}{\\begin{texttt}}{\\end{texttt}} \\newcommand{\\linline}[2]{#2} \\begin{document} ... \\end{document} Executable sections is the document are enclosed with the python tags, results - wtih result tags: \\begin{python} W='Hello, World!' print(W) \\end{python} \\begin{result} Hello, World! \\end{result} LitREPL recognizes result / noresult LaTeX comments as result section markers. This way we can use Python to emit LaTeX markup as output. %result Hello, World! %noresult Additionally, LitREPL recognises linline 2-argument tags. The first arguement is treated as a Python printable expression. The second arguemnt is an immediate result section where the value of expression will be placed. \\linline{W}{Hello, World!} In-PDF code highliting with Minted The following Latex instructions can be used to properly highlight the code and result sections. Note, that pygmentize system tool needs to be installed in the system. \\usepackage{minted} \\renewcommand{\\MintedPygmentize}{pygmentize} % LitREPL-compatible environment for Python code snippets \\newenvironment{python} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{python}} {\\end{minted}} \\BeforeBeginEnvironment{python}{\\begin{mdframed}[nobreak=false,everyline=true]} \\AfterEndEnvironment{python}{\\end{mdframed}} % LitREPL-compatible ai secitons \\newenvironment{ai} {\\vsp\\textbf{User:}\\vsp} {} \\newenvironment{airesult} {\\vsp\\textbf{AI:}\\vsp} {} % LitREPL-compatible environment for code results \\newenvironment{result} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{text}} {\\end{minted}} \\BeforeBeginEnvironment{result}{\\begin{mdframed}[nobreak=true,frametitle=\\tiny{Result}]} \\AfterEndEnvironment{result}{\\end{mdframed}} % LitREPL-compatible command for inline code results \\newcommand{\\linline}[2]{#2} \\newcommand{\\st}[1]{\\sout{#1}} \\renewcommand{\\t}[1]{\\texttt{#1}} Hint: Use \\usepackage[outputdir=_build]{minted} if you specify a separate build directory (here - _build ). This workarounds a well-known Minted problem. Vim In-editor code highlighting with Vimtex The following .vimrc Vimtex configuration enables highlighting of Python code sections in LaTeX documents. We typically need to call these functions from the BufEnter event handler. \" .localvimrc call vimtex#syntax#nested#include('python') call vimtex#syntax#core#new_region_env('texLitreplZone', 'l[a-zA-Z0-9]*code', \\ {'contains': '@vimtex_nested_python'})","title":"Formatting"},{"location":"usage/formatting/#formatting","text":"","title":"Formatting"},{"location":"usage/formatting/#markdown","text":"","title":"Markdown"},{"location":"usage/formatting/#basic-syntax","text":"Executable sections are verbatim sections marked with a number of tags, including \"python\" and \"code\". ``` python W='Hello, World!' print(W) ``` Verbatim result sections might be marked as \"result\" or \"lresult\". ``` result Hello, World! ``` Markdown comments tagged with result / noresult (see an example below) also mark result sections. This syntax allows emitting parts of Markdown document. <!-- result --> Hello, World! <!-- noresult -->","title":"Basic syntax"},{"location":"usage/formatting/#latex","text":"","title":"Latex"},{"location":"usage/formatting/#basic-syntax_1","text":"Litrepl treats \\begin{python}\\end{python} environment as code sections and \\begin{result}\\end{result} environment as result sections. The names are currently hardcoded into the simplified LitREPL parser. Wrapping it in other tags is not allowed. LaTeX does not know anything about these environments by default, so we need to introduce these environments in the preamble: \\documentclass{article} \\usepackage[utf8]{inputenc} \\begin{document} \\newenvironment{python}{\\begin{texttt}}{\\end{texttt}} \\newenvironment{result}{\\begin{texttt}}{\\end{texttt}} \\newcommand{\\linline}[2]{#2} \\begin{document} ... \\end{document} Executable sections is the document are enclosed with the python tags, results - wtih result tags: \\begin{python} W='Hello, World!' print(W) \\end{python} \\begin{result} Hello, World! \\end{result} LitREPL recognizes result / noresult LaTeX comments as result section markers. This way we can use Python to emit LaTeX markup as output. %result Hello, World! %noresult Additionally, LitREPL recognises linline 2-argument tags. The first arguement is treated as a Python printable expression. The second arguemnt is an immediate result section where the value of expression will be placed. \\linline{W}{Hello, World!}","title":"Basic syntax"},{"location":"usage/formatting/#in-pdf-code-highliting-with-minted","text":"The following Latex instructions can be used to properly highlight the code and result sections. Note, that pygmentize system tool needs to be installed in the system. \\usepackage{minted} \\renewcommand{\\MintedPygmentize}{pygmentize} % LitREPL-compatible environment for Python code snippets \\newenvironment{python} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{python}} {\\end{minted}} \\BeforeBeginEnvironment{python}{\\begin{mdframed}[nobreak=false,everyline=true]} \\AfterEndEnvironment{python}{\\end{mdframed}} % LitREPL-compatible ai secitons \\newenvironment{ai} {\\vsp\\textbf{User:}\\vsp} {} \\newenvironment{airesult} {\\vsp\\textbf{AI:}\\vsp} {} % LitREPL-compatible environment for code results \\newenvironment{result} {\\VerbatimEnvironment \\begin{minted}[autogobble,breaklines,fontsize=\\footnotesize]{text}} {\\end{minted}} \\BeforeBeginEnvironment{result}{\\begin{mdframed}[nobreak=true,frametitle=\\tiny{Result}]} \\AfterEndEnvironment{result}{\\end{mdframed}} % LitREPL-compatible command for inline code results \\newcommand{\\linline}[2]{#2} \\newcommand{\\st}[1]{\\sout{#1}} \\renewcommand{\\t}[1]{\\texttt{#1}} Hint: Use \\usepackage[outputdir=_build]{minted} if you specify a separate build directory (here - _build ). This workarounds a well-known Minted problem.","title":"In-PDF code highliting with Minted"},{"location":"usage/formatting/#vim-in-editor-code-highlighting-with-vimtex","text":"The following .vimrc Vimtex configuration enables highlighting of Python code sections in LaTeX documents. We typically need to call these functions from the BufEnter event handler. \" .localvimrc call vimtex#syntax#nested#include('python') call vimtex#syntax#core#new_region_env('texLitreplZone', 'l[a-zA-Z0-9]*code', \\ {'contains': '@vimtex_nested_python'})","title":"Vim In-editor code highlighting with Vimtex"},{"location":"usage/general-concepts/","text":"General concepts The Litrepl tool identifies code and result sections within a text document. It processes the code by sending it to the appropriate interpreters and populates the result sections with their responses. The interpreters remain active in the background, ready to handle new inputs. Litrepl supports subsets of Markdown and LaTeX formatting in order to recognize the sections. Some aspects of the recognized grammars, such as section labels, could be configured. As an illustration, consider the combined usage of Litrepl (via the Vim plugin ) with the Vimtex to edit and preview LaTeX documents instantly. (Note: some browsers might refuse to play the video) Basic Execution Litrepl searches for verbatim code sections followed by zero or more result sections. In Markdown documents, the Python code is any triple-quoted section with a pre-configured label such as python . The result is any triple-quoted result section. In LaTeX documents, sections are marked with \\begin{...}\\end{...} environments correspondingly. The primary command for evaluating formatted documents is litrepl eval-sections which starts the background interactive session (unless --foreground is specified), and process the document. Consider a markdown document file.md . ``` python print('Hello Markdown!') ``` ``` result ``` We pass it to Litrepl using: $ cat file.md | litrepl eval-sections > result.md The result.md will have all sections filled in correctly. ``` python print('Hello Markdown!') ``` ``` result Hello Markdown! ``` For additional details on Markdown formatting, refer to Formatting Markdown documents In a similar LaTeX document, the code and result sections would be: \\begin{python} print('Hello LaTeX!') \\end{python} \\begin{result} Hello LaTeX! \\end{result} LaTeX documents require a preamble introducing python/result environments to the TeX processor. For more information, see Formatting LaTeX documents . By default, Litrepl tried to guess the format of the input document. Use the --filetype=(latex|markdown) option to set the format explicitly: $ cat doc.md | litrepl --filetype=markdown eval-sections $ cat doc.tex | litrepl --filetype=latex eval-sections Selecting Sections for Execution By default, litrepl eval-sections evaluates all sections in a document. To evaluate only specific sections, the range argument should be specified. The overall syntax is litrepl eval-sections [RANGE] , where RANGE can be: x : Represents a specific code section to evaluate, with the following possible formats: N : absolute section number in the document starting from 1 . $ symbol, indicating the last section. L:C , referring to the line and column position. Litrepl calculates the section number based on this position. +N or -N : section number relative to the section corresponding to the last line-column position within the current query. X..X : Represents a range of sections, determined using the rules mentioned above. X,X : List of sections to execute Some examples: $ litrepl eval-sections '0' # First section in a document $ litrepl eval-sections '3..$' # Sections from fourth section (zero based) to the last one $ litrepl eval-sections '34:1..$' # Sections starting from line 34 column 1 $ litrepl eval-sections '34:1,+1' # Section at line 34 column 1 and the next one Managing Interpreter Sessions Each interpreter session uses an auxiliary directory where Litrepl stores filesystem pipes and other runtime data. By default, the auxiliary directory path is derived from the working directory name (for Vim, this defaults to the directory of the current file). This behavior can be configured by: * Setting the working directory with LITREPL_WORKDIR environment variable or --workdir=DIR command-line argument (this may also affect the current directory of the interpreters), or * Explicitly setting the auxiliary directory with LITREPL_<CLASS>_AUXDIR environment variable or --<class>-auxdir=DIR command-line argument, where <class> stands for either python , ai or sh . The commands litrepl start CLASS , litrepl stop [CLASS] , and litrepl restart [CLASS] are used to manage interpreter sessions. They accept the interpreter type to operate on or (for some commands) the keyword all to apply the command to all interpreters. Add the --<class>-interpteter=CMDLINE to adjust the command line to run, but be careful - Litrepl adds more arguments to configure prompts and verbosity to some interpreters, notably to the pythons. $ litrepl --python-interpreter=ipython start python $ litrepl --sh-interpreter=/opt/bin/mybash start sh $ litrepl restart all $ litrepl stop The litrepl status [CLASS] command queries the information about the currently running interpreters. The command reveals the process PID and the command-line arguments. For stopped interpreters, the last exit codes are also listed. Specifying CLASS prints the status for this class of interpreters only. $ litrepl status # Format: # CLASS PID EXITCODE CMD python 3900919 - python3 -m IPython --config=/tmp/litrepl_1000_a2732d/python/litrepl_ipython_config.py --colors=NoColor -i ai 3904696 - aicli --readline-prompt= Asynchronous Processing Litrepl can generate an output document before the interpreter has finished processing. If the evaluation takes longer than a timeout, Litrepl leaves a marker, enabling it to continue from where it was stopped during future runs. The --timeout=SEC[,SEC] option allows you to set timeouts. The first number specifies the initial execution timeout in seconds, while the optional second number sets the timeout for subsequent attempts. By default, both timeouts are set to infinity. For instance, executing litrepl --timeout=3.5 eval-sections on the corresponding program yields: ``` python from tqdm import tqdm from time import sleep for i in tqdm(range(10)): sleep(1) ``` ``` result 30%|\u2588\u2588\u2588 | 3/10 [00:03<00:07, 1.00s/it] [BG:/tmp/nix-shell.vijcH0/litrepl_1000_a2732d/python/litrepl_eval_5503542553591491252.txt] ``` Upon re-executing the document, Litrepl resumes processing from the marker. Once evaluation concludes, it removes the marker from the output section. The command litrepl interrupt sends an interrupt signal to the interpreter, prompting it to return control sooner (with an exception). Attaching Interpreter Sessions The command litrepl repl CLASS where CLASS specifies interpreter class: python ai or sh , attaches to interpreter sessions. For this command to work, socat tool needs to be installed on your system. Litrepl blocks the pipes for the time of interaction so no evaluation is possible while the repl session is active. For Python and Shell interpreters, the command prompt is disabled which is a current technical limitation. Use Ctrl+D to safely detach the session. For example: $ litrepl repl python Opening the interpreter terminal (NO PROMPTS, USE `Ctrl+D` TO DETACH) W = 'Hello from repl' ^D $ Use litrepl eval-code CLASS to direct code straight to the interpreter, bypassing any section formatting steps. In contrast to the repl command, eval-code mode features prompt detection, allowing the tool to display the interpreter's response and detach while keeping the session open. For example, after manually defining the W variable in the example above, it can be queried as in a typical IPython session. $ echo 'W' | litrepl eval-code 'Hello from repl' The eval-code command can be utilized for batch processing and managing sessions, in a manner similar to how the expect tool is used. Experimental AI Features Litrepl experimentally supports Aicli terminal allowing users to query external language models. In order to try it, install the interpreter and use ai as the name for code sections. For low-speed models it might be convenient to use :LEvalMon command to monitor the text generation in real time. ``` ai /model gpt4all:\"./_models/Meta-Llama-3-8B-Instruct.Q4_0.gguf\" Hi chat! What is your name? ``` ``` result I'm LLaMA, a large language model trained by Meta AI. I'm here to help answer any questions you might have and provide information on a wide range of topics. How can I assist you today? ``` All Aicli / -commands like the /model command above are passed as-is to the interpreter. The /ask command is added automatically at the of each section, so make sure that ai secions have self-contained questions. As a pre-processing step, Litrepl can paste text from other sections of the document in place of special reference markers. The markers have the following format: >>RX<< , where X is a number - references a section number X (starting from zero). ^^RX^^ , where X is a number - references the section X times above the current one. vvRXvv , where X is a number - references the section X times below the current one. ``` ai AI, what do you think the following text means? ^^R1^^ ``` ``` result Another interesting piece of text! This is an example of a chatbot introduction or \"hello message.\" It appears to be written in a friendly, approachable tone, with the goal of establishing a connection with users. ```","title":"General concepts"},{"location":"usage/general-concepts/#general-concepts","text":"The Litrepl tool identifies code and result sections within a text document. It processes the code by sending it to the appropriate interpreters and populates the result sections with their responses. The interpreters remain active in the background, ready to handle new inputs. Litrepl supports subsets of Markdown and LaTeX formatting in order to recognize the sections. Some aspects of the recognized grammars, such as section labels, could be configured. As an illustration, consider the combined usage of Litrepl (via the Vim plugin ) with the Vimtex to edit and preview LaTeX documents instantly. (Note: some browsers might refuse to play the video)","title":"General concepts"},{"location":"usage/general-concepts/#basic-execution","text":"Litrepl searches for verbatim code sections followed by zero or more result sections. In Markdown documents, the Python code is any triple-quoted section with a pre-configured label such as python . The result is any triple-quoted result section. In LaTeX documents, sections are marked with \\begin{...}\\end{...} environments correspondingly. The primary command for evaluating formatted documents is litrepl eval-sections which starts the background interactive session (unless --foreground is specified), and process the document. Consider a markdown document file.md . ``` python print('Hello Markdown!') ``` ``` result ``` We pass it to Litrepl using: $ cat file.md | litrepl eval-sections > result.md The result.md will have all sections filled in correctly. ``` python print('Hello Markdown!') ``` ``` result Hello Markdown! ``` For additional details on Markdown formatting, refer to Formatting Markdown documents In a similar LaTeX document, the code and result sections would be: \\begin{python} print('Hello LaTeX!') \\end{python} \\begin{result} Hello LaTeX! \\end{result} LaTeX documents require a preamble introducing python/result environments to the TeX processor. For more information, see Formatting LaTeX documents . By default, Litrepl tried to guess the format of the input document. Use the --filetype=(latex|markdown) option to set the format explicitly: $ cat doc.md | litrepl --filetype=markdown eval-sections $ cat doc.tex | litrepl --filetype=latex eval-sections","title":"Basic Execution"},{"location":"usage/general-concepts/#selecting-sections-for-execution","text":"By default, litrepl eval-sections evaluates all sections in a document. To evaluate only specific sections, the range argument should be specified. The overall syntax is litrepl eval-sections [RANGE] , where RANGE can be: x : Represents a specific code section to evaluate, with the following possible formats: N : absolute section number in the document starting from 1 . $ symbol, indicating the last section. L:C , referring to the line and column position. Litrepl calculates the section number based on this position. +N or -N : section number relative to the section corresponding to the last line-column position within the current query. X..X : Represents a range of sections, determined using the rules mentioned above. X,X : List of sections to execute Some examples: $ litrepl eval-sections '0' # First section in a document $ litrepl eval-sections '3..$' # Sections from fourth section (zero based) to the last one $ litrepl eval-sections '34:1..$' # Sections starting from line 34 column 1 $ litrepl eval-sections '34:1,+1' # Section at line 34 column 1 and the next one","title":"Selecting Sections for Execution"},{"location":"usage/general-concepts/#managing-interpreter-sessions","text":"Each interpreter session uses an auxiliary directory where Litrepl stores filesystem pipes and other runtime data. By default, the auxiliary directory path is derived from the working directory name (for Vim, this defaults to the directory of the current file). This behavior can be configured by: * Setting the working directory with LITREPL_WORKDIR environment variable or --workdir=DIR command-line argument (this may also affect the current directory of the interpreters), or * Explicitly setting the auxiliary directory with LITREPL_<CLASS>_AUXDIR environment variable or --<class>-auxdir=DIR command-line argument, where <class> stands for either python , ai or sh . The commands litrepl start CLASS , litrepl stop [CLASS] , and litrepl restart [CLASS] are used to manage interpreter sessions. They accept the interpreter type to operate on or (for some commands) the keyword all to apply the command to all interpreters. Add the --<class>-interpteter=CMDLINE to adjust the command line to run, but be careful - Litrepl adds more arguments to configure prompts and verbosity to some interpreters, notably to the pythons. $ litrepl --python-interpreter=ipython start python $ litrepl --sh-interpreter=/opt/bin/mybash start sh $ litrepl restart all $ litrepl stop The litrepl status [CLASS] command queries the information about the currently running interpreters. The command reveals the process PID and the command-line arguments. For stopped interpreters, the last exit codes are also listed. Specifying CLASS prints the status for this class of interpreters only. $ litrepl status # Format: # CLASS PID EXITCODE CMD python 3900919 - python3 -m IPython --config=/tmp/litrepl_1000_a2732d/python/litrepl_ipython_config.py --colors=NoColor -i ai 3904696 - aicli --readline-prompt=","title":"Managing Interpreter Sessions"},{"location":"usage/general-concepts/#asynchronous-processing","text":"Litrepl can generate an output document before the interpreter has finished processing. If the evaluation takes longer than a timeout, Litrepl leaves a marker, enabling it to continue from where it was stopped during future runs. The --timeout=SEC[,SEC] option allows you to set timeouts. The first number specifies the initial execution timeout in seconds, while the optional second number sets the timeout for subsequent attempts. By default, both timeouts are set to infinity. For instance, executing litrepl --timeout=3.5 eval-sections on the corresponding program yields: ``` python from tqdm import tqdm from time import sleep for i in tqdm(range(10)): sleep(1) ``` ``` result 30%|\u2588\u2588\u2588 | 3/10 [00:03<00:07, 1.00s/it] [BG:/tmp/nix-shell.vijcH0/litrepl_1000_a2732d/python/litrepl_eval_5503542553591491252.txt] ``` Upon re-executing the document, Litrepl resumes processing from the marker. Once evaluation concludes, it removes the marker from the output section. The command litrepl interrupt sends an interrupt signal to the interpreter, prompting it to return control sooner (with an exception).","title":"Asynchronous Processing"},{"location":"usage/general-concepts/#attaching-interpreter-sessions","text":"The command litrepl repl CLASS where CLASS specifies interpreter class: python ai or sh , attaches to interpreter sessions. For this command to work, socat tool needs to be installed on your system. Litrepl blocks the pipes for the time of interaction so no evaluation is possible while the repl session is active. For Python and Shell interpreters, the command prompt is disabled which is a current technical limitation. Use Ctrl+D to safely detach the session. For example: $ litrepl repl python Opening the interpreter terminal (NO PROMPTS, USE `Ctrl+D` TO DETACH) W = 'Hello from repl' ^D $ Use litrepl eval-code CLASS to direct code straight to the interpreter, bypassing any section formatting steps. In contrast to the repl command, eval-code mode features prompt detection, allowing the tool to display the interpreter's response and detach while keeping the session open. For example, after manually defining the W variable in the example above, it can be queried as in a typical IPython session. $ echo 'W' | litrepl eval-code 'Hello from repl' The eval-code command can be utilized for batch processing and managing sessions, in a manner similar to how the expect tool is used.","title":"Attaching Interpreter Sessions"},{"location":"usage/general-concepts/#experimental-ai-features","text":"Litrepl experimentally supports Aicli terminal allowing users to query external language models. In order to try it, install the interpreter and use ai as the name for code sections. For low-speed models it might be convenient to use :LEvalMon command to monitor the text generation in real time. ``` ai /model gpt4all:\"./_models/Meta-Llama-3-8B-Instruct.Q4_0.gguf\" Hi chat! What is your name? ``` ``` result I'm LLaMA, a large language model trained by Meta AI. I'm here to help answer any questions you might have and provide information on a wide range of topics. How can I assist you today? ``` All Aicli / -commands like the /model command above are passed as-is to the interpreter. The /ask command is added automatically at the of each section, so make sure that ai secions have self-contained questions. As a pre-processing step, Litrepl can paste text from other sections of the document in place of special reference markers. The markers have the following format: >>RX<< , where X is a number - references a section number X (starting from zero). ^^RX^^ , where X is a number - references the section X times above the current one. vvRXvv , where X is a number - references the section X times below the current one. ``` ai AI, what do you think the following text means? ^^R1^^ ``` ``` result Another interesting piece of text! This is an example of a chatbot introduction or \"hello message.\" It appears to be written in a friendly, approachable tone, with the goal of establishing a connection with users. ```","title":"Experimental AI Features"},{"location":"usage/vim-plugin/","text":"Vim plugin Litrepl comes with a reference Vim plugin, which interfaces Litrepl using its command-line interface. As specified in the Reference section, the plugin mirrows most modes of operation by its commands, that typically starts from capital L . Many options are also mirrored by the vim variables. Installation Installing release versions from Vim.org Download the latest vim-litrepl-*.tar.gz from the vim.org script page and unpack it into your ~/.vim folder with tar -xf vim-litrepl-*.tar.gz -C ~/.vim Installing latest versions from Git using Vim-Plug Install the Vim plugin by adding the following line between the plug#begin and plug#end lines of your .vimrc file: Plug 'https://github.com/sergei-mironov/litrepl' , { 'rtp': 'vim' } Note: rtp sets the custom vim-plugin source directory of the plugin. Installing latest versions from source using Nix To include the Litrepl Vim plugin to the Litrepl installation, add vim-litrepl-release to the vimPlugins list within your vim_configurable expression. Installing latest versions from source using Pip Installing Vim plugin requires hand-copying ./vim/plugin/litrepl.vim and ./vim/plugin/litrepl_extras.vim to the ~/.vim config folder. Basic execution The main Vim command for code section evaluation is :LEval . By default, it executes the section at the cursor. To execute all sections in a document, use :LEval all . Selecting Sections for Execution The Vim command :LEval accepts eval-section syntax with the following additions: @ symbol gets replaced with the L:C formatted cursor position Words all , above , and below get replaced by the corresponding ranges, relative to the current cursor position. Managing Interpreter Sessions Interpreter sessions could be managed from Vim using the :LStart CLASS , :LStop [CLASS] , and :LRestart [CLASS] commands which gets directed to their start , stop and restart CLI versions. Vim command :LStatus corresponds to the litrepl status CLI command. The status message gets printed into the newly-opened Vim buffer. No CLASS argument is currently supported. Asynchronous Processing The :LEval command aims at synchronous execution. For convenience, Vim plugin defines the :LEvalAsync that has 0.5-second initial execution timeout. The :LInterrupt command is equivalent to litrepl interrupt CLI command. Vim plugin also provides the :LEvalMon command, which facilitates continuous code evaluation with no delay. Interrupting this with Ctrl+C will make Litrepl return control to the editor, leaving the evaluation ongoing in the background. Attaching Interpreter Sessions The equivalent Vim commands are :LRepl [CLASS] or :LTerm [CLASS] . Both commands open Vim terminal window.","title":"Vim plugin"},{"location":"usage/vim-plugin/#vim-plugin","text":"Litrepl comes with a reference Vim plugin, which interfaces Litrepl using its command-line interface. As specified in the Reference section, the plugin mirrows most modes of operation by its commands, that typically starts from capital L . Many options are also mirrored by the vim variables.","title":"Vim plugin"},{"location":"usage/vim-plugin/#installation","text":"","title":"Installation"},{"location":"usage/vim-plugin/#installing-release-versions-from-vimorg","text":"Download the latest vim-litrepl-*.tar.gz from the vim.org script page and unpack it into your ~/.vim folder with tar -xf vim-litrepl-*.tar.gz -C ~/.vim","title":"Installing release versions from Vim.org"},{"location":"usage/vim-plugin/#installing-latest-versions-from-git-using-vim-plug","text":"Install the Vim plugin by adding the following line between the plug#begin and plug#end lines of your .vimrc file: Plug 'https://github.com/sergei-mironov/litrepl' , { 'rtp': 'vim' } Note: rtp sets the custom vim-plugin source directory of the plugin.","title":"Installing latest versions from Git using Vim-Plug"},{"location":"usage/vim-plugin/#installing-latest-versions-from-source-using-nix","text":"To include the Litrepl Vim plugin to the Litrepl installation, add vim-litrepl-release to the vimPlugins list within your vim_configurable expression.","title":"Installing latest versions from source using Nix"},{"location":"usage/vim-plugin/#installing-latest-versions-from-source-using-pip","text":"Installing Vim plugin requires hand-copying ./vim/plugin/litrepl.vim and ./vim/plugin/litrepl_extras.vim to the ~/.vim config folder.","title":"Installing latest versions from source using Pip"},{"location":"usage/vim-plugin/#basic-execution","text":"The main Vim command for code section evaluation is :LEval . By default, it executes the section at the cursor. To execute all sections in a document, use :LEval all .","title":"Basic execution"},{"location":"usage/vim-plugin/#selecting-sections-for-execution","text":"The Vim command :LEval accepts eval-section syntax with the following additions: @ symbol gets replaced with the L:C formatted cursor position Words all , above , and below get replaced by the corresponding ranges, relative to the current cursor position.","title":"Selecting Sections for Execution"},{"location":"usage/vim-plugin/#managing-interpreter-sessions","text":"Interpreter sessions could be managed from Vim using the :LStart CLASS , :LStop [CLASS] , and :LRestart [CLASS] commands which gets directed to their start , stop and restart CLI versions. Vim command :LStatus corresponds to the litrepl status CLI command. The status message gets printed into the newly-opened Vim buffer. No CLASS argument is currently supported.","title":"Managing Interpreter Sessions"},{"location":"usage/vim-plugin/#asynchronous-processing","text":"The :LEval command aims at synchronous execution. For convenience, Vim plugin defines the :LEvalAsync that has 0.5-second initial execution timeout. The :LInterrupt command is equivalent to litrepl interrupt CLI command. Vim plugin also provides the :LEvalMon command, which facilitates continuous code evaluation with no delay. Interrupting this with Ctrl+C will make Litrepl return control to the editor, leaving the evaluation ongoing in the background.","title":"Asynchronous Processing"},{"location":"usage/vim-plugin/#attaching-interpreter-sessions","text":"The equivalent Vim commands are :LRepl [CLASS] or :LTerm [CLASS] . Both commands open Vim terminal window.","title":"Attaching Interpreter Sessions"}]}